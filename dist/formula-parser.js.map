{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 53b2117c969a4c36624b","webpack:///./index.js","webpack:///./src/parser.js","webpack:///./src/supported-formulas.js","webpack:///./~/tiny-emitter/index.js","webpack:///./src/evaluate-by-operator/evaluate-by-operator.js","webpack:///./src/evaluate-by-operator/operator/add.js","webpack:///./src/helper/number.js","webpack:///./src/error.js","webpack:///./src/helper/undefined-cell.js","webpack:///./~/decimal.js/decimal.js","webpack:///./src/evaluate-by-operator/operator/ampersand.js","webpack:///./src/evaluate-by-operator/operator/divide.js","webpack:///./src/evaluate-by-operator/operator/equal.js","webpack:///./src/evaluate-by-operator/operator/formula-function.js","webpack:///./~/formulajs/index.js","webpack:///./~/formulajs/lib/compatibility.js","webpack:///./~/formulajs/lib/math-trig.js","webpack:///./~/formulajs/lib/utils.js","webpack:///./~/formulajs/lib/error.js","webpack:///./~/formulajs/lib/statistical.js","webpack:///./~/formulajs/lib/text.js","webpack:///./~/jStat/dist/jstat.js","webpack:///./~/formulajs/lib/miscellaneous.js","webpack:///./~/formulajs/lib/information.js","webpack:///./~/formulajs/lib/engineering.js","webpack:///./~/bessel/bessel.js","webpack:///./~/formulajs/lib/date-time.js","webpack:///./~/formulajs/lib/database.js","webpack:///./~/formulajs/lib/logical.js","webpack:///./~/formulajs/lib/financial.js","webpack:///./~/formulajs/lib/lookup-reference.js","webpack:///./src/evaluate-by-operator/operator/greater-than.js","webpack:///./src/evaluate-by-operator/operator/greater-than-or-equal.js","webpack:///./src/evaluate-by-operator/operator/less-than.js","webpack:///./src/evaluate-by-operator/operator/less-than-or-equal.js","webpack:///./src/evaluate-by-operator/operator/minus.js","webpack:///./src/evaluate-by-operator/operator/multiply.js","webpack:///./src/evaluate-by-operator/operator/not-equal.js","webpack:///./src/evaluate-by-operator/operator/power.js","webpack:///./src/grammar-parser/grammar-parser.js","webpack:///(webpack)/buildin/module.js","webpack:///external \"fs\"","webpack:///external \"path\"","webpack:///./src/helper/string.js","webpack:///./src/helper/cell.js"],"names":["SUPPORTED_FORMULAS","ERROR","ERROR_DIV_ZERO","ERROR_NAME","ERROR_NOT_AVAILABLE","ERROR_NULL","ERROR_NUM","ERROR_REF","ERROR_VALUE","Parser","error","extractLabel","toLabel","columnIndexToLabel","columnLabelToIndex","rowIndexToLabel","rowLabelToIndex","default","parser","GrammarParser","yy","toNumber","trimEdges","invertNumber","throwError","errorName","_throwError","callVariable","variable","_callVariable","evaluateByOperator","callFunction","cellValue","value","sheet","_callCellValue","rangeValue","start","end","_callRangeValue","variables","Object","create","setVariable","expression","result","parse","ex","message","Error","name","getVariable","emit","newValue","label","toUpperCase","row","column","cellCoordinate","_value","startLabel","endLabel","startRow","startColumn","endRow","endColumn","startCell","endCell","index","Emitter","registerOperation","availableOperators","Decimal","set","precision","add","SYMBOL","ampersand","divide","equal","power","formulaFunction","greaterThan","greaterThanOrEqual","lessThan","lessThanOrEqual","multiply","notEqual","minus","operator","params","symbol","func","Array","isArray","forEach","s","isFactory","first","rest","i","length","reduce","acc","plus","isNaN","number","indexOf","parseFloat","parseInt","isValidStrict","errors","type","replace","valid","hasOwnProperty","undefinedCell","undefined","toString","tempValue","div","Infinity","exp1","exp2","formulajs","symbolParts","split","foundFormula","nestedFormula","mul","Number","isInteger","toPower","o","k","v","l","$V0","$V1","$V2","$V3","$V4","$V5","$V6","$V7","$V8","$V9","$Va","$Vb","$Vc","$Vd","$Ve","$Vf","$Vg","$Vh","$Vi","$Vj","$Vk","$Vl","$Vm","$Vn","$Vo","$Vp","$Vq","$Vr","$Vs","$Vt","$Vu","trace","symbols_","terminals_","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","$","n1","textInArray","arr","eval","item","push","table","defaultActions","parseError","str","hash","recoverable","input","self","stack","tstack","vstack","lstack","recovering","TERROR","EOF","args","slice","call","arguments","lexer","sharedState","prototype","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","n","_token_stack","lex","token","preErrorSymbol","state","action","a","r","yyval","p","len","newState","expected","_handle_error","locateNearestErrorRecoveryRule","stack_probe","depth","error_rule_depth","errStr","showPosition","join","text","match","line","loc","first_line","last_line","first_column","last_column","range","apply","concat","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","c","test_match","indexed_rule","backup","matches","tempMatch","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","YYSTATE","exports","main","commonjsMain","console","log","process","exit","source","require","readFileSync","normalize","module","argv","string","margin","substring","LABEL_EXTRACT_REGEXP","test","columnAbs","rowAbs","isAbsolute","rowLabel","columnLabel","COLUMN_LABEL_BASE","COLUMN_LABEL_BASE_LENGTH","j","pow","String","fromCharCode","floor","max"],"mappings":"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QAAQA,KAAR,GAAgB,IAAvB;AACD;;AAED;;;;;;AAMO,UAASoG,aAAT,CAAuBE,IAAvB,EAA6B;AAClC,OAAIE,QAAQ,KAAZ;;AAEA,QAAK,IAAId,CAAT,IAAcW,MAAd,EAAsB;AACpB,SAAIA,OAAOI,cAAP,CAAsBf,CAAtB,KAA4BW,OAAOX,CAAP,MAAcY,IAA9C,EAAoD;AAClDE,eAAQ,IAAR;AACA;AACD;AACF;;AAED,UAAOA,KAAP;AACD,E;;;;;;;;;;;SCvDeE,a,GAAAA,a;AAAT,UAASA,aAAT,CAAuBnF,KAAvB,EAA8B;AACnC,OAAIA,UAAUoF,SAAV,IAAuBpF,UAAU,EAAjC,IAAuCA,UAAU,IAArD,EAA2D;AACzD,YAAO,CAAP;AACD,IAFD,MAEO;AACL,YAAOA,KAAP;AACD;AACF,E;;;;;;ACND;AACA,EAAC;AACD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B,gBAAgB,EAAE;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,oDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;;AAGL;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA0C,OAAO;AACjD;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET,iDAAgD,IAAI,OAAO,IAAI;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAe,GAAG;;AAElB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;;AAEA,yCAAwC,0BAA0B;AAClE;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,uBAAsB,cAAc;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,KAAK;AACtB;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA6B,OAAO;;AAEpC;AACA,wBAAuB,OAAO;;AAE9B;AACA,oBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAU,iBAAiB;;AAE3B;AACA,WAAU,aAAa;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,KAAK;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,GAAG;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB,gBAAgB;;AAEzC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET,iDAAgD,IAAI,OAAO,IAAI;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,KAAK;;AAErB;AACA,kBAAiB,UAAU;AAC3B;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAU,UAAU;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B,YAAW,OAAO;AAClB;AACA,kDAAiD,GAAG;AACpD,gDAA+C,GAAG;AAClD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,GAAG,SAAS,GAAG;AAC5B;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA,oCAAmC,GAAG;AACtC,sCAAqC,GAAG;AACxC,6CAA4C,GAAG;AAC/C,2CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,WAAU,cAAc;;AAExB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,SAAS;;AAE3B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU,UAAU;AACpB,8BAA6B,QAAQ;AACrC;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,oBAAmB,KAAK;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAAyB,KAAK;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA,aAAY,uBAAuB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,uBAAuB;;AAExC;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAgB,WAAW;;AAE3B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,+BAA8B,SAAS;AACvC;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,SAAS;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;;AAEA;AACA,2BAA0B,SAAS;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAe;;AAEf;AACA;;AAEA;AACA,mCAAkC,SAAS;AAC3C;AACA,wBAAuB,SAAS;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,eAAe;AACxC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,yBAAwB,SAAS;AACjC;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAY,aAAa;;AAEzB;AACA,0BAAyB,SAAS;AAClC;;AAEA;AACA;;;AAGA;AACA;AACA,WAAU,KAAK;AACf;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC;AACrC;;AAEA;;AAEA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU,mBAAmB;AAC7B;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,gBAAe,0BAA0B;;AAEzC;AACA,2BAA0B,gCAAgC;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B,SAAS;AACtC;AACA;AACA,QAAO;AACP;AACA;;AAEA,aAAY,KAAK;AACjB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA2C,kBAAkB;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAY,gBAAgB;;AAE5B;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,cAAc;;AAE3C;AACA,8BAA6B,SAAS;;AAEtC;AACA;AACA;AACA;AACA;AACA,0BAAyB,SAAS;AAClC;AACA,oCAAmC,cAAc;;AAEjD;AACA,sCAAqC,SAAS;AAC9C,cAAa;AACb;AACA;AACA;;AAEA;AACA,UAAS;AACT,iBAAgB,KAAK;AACrB;AACA,UAAS;AACT,wCAAuC,MAAM;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB;AACA,2BAA0B,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,6BAA4B,SAAS;AACrC;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA,2BAA0B;AAC1B;AACA,2BAA0B;AAC1B;AACA,yBAAwB;AACxB;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA,2BAA0B;AAC1B,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA,yBAAwB;AACxB;AACA;AACA;AACA,yBAAwB;AACxB,2BAA0B;;AAE1B;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR,SAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ,sBAAsB;AAC9B,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAY,OAAO;;AAEnB;AACA,MAAK;AACL;;AAEA,aAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA,aAAY,OAAO;;AAEnB;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU,aAAa;;AAEvB;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,aAAY,aAAa;;AAEzB;AACA,6BAA4B,SAAS;;AAErC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AAC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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,IAAI,cAAc,IAAI,cAAc,IAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;;AAEA;;AAEA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,kBAAkB;AACrC,2EAA0E;AAC1E;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC,qGAAoG;AACpG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,sBAAqB,4BAA4B;AACjD;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1oCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gB;AACA;AACA;;AAEA,0C;AACA,sC;AACA;AACA,MAAK;AACL,IAAG;AACH;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAa,SAAS;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA,uCAAsC;AACtC;AACA;AACA,MAAK;AACL,mDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA,8DAA6D;AAC7D,QAAO;AACP,0EAAyE;AACzE;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,QAAQ;AACzB;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAa,mBAAmB;AAChC;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACxwDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACzSA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,oBAAoB;AACzC;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;;;AAGA;AACA;AACA;AACA,4CAA2C,cAAc;AACzD;;;AAGA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,UAAU;AAC3B;AACA,gBAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe,YAAY;AAC3B;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,UAAU;AAC3B;AACA,gBAAe,UAAU;AACzB;AACA;;AAEA;AACA;;;AAGA,qBAAoB,UAAU;;;AAG9B;AACA;AACA;AACA;AACA;AACA;;;AAGA,oBAAmB,UAAU;;;AAG7B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA,0BAAyB,wBAAwB;;;AAGjD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAe,YAAY;AAC3B,kBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;;AAGA;AACA,aAAY,KAAK,MAAM,MAAM,SAAS;AACtC,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA,MAAK;AACL,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,EAAC;;;AAGD;AACA,mBAAkB,KAAK,QAAQ,MAAM,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA,sEAAqE;AACrE,IAAG;AACH,EAAC;;;AAGD;AACA;;AAEA,EAAC;AACD;;AAEA;;AAEA;AACA,wBAAuB,cAAc;;AAErC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gBAAe;AACf,iBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gDAA+C,cAAc,EAAE;AAC/D;;;AAGA;AACA;AACA,gDAA+C,cAAc,EAAE;AAC/D;;;AAGA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD,oCAAoC;AACvF,iDAAgD,2BAA2B;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,QAAQ;AACtC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,+BAA8B,QAAQ;AACtC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;AACA,kBAAiB,SAAS;AAC1B;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,aAAa;AAC9B;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA,wEAAuE;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,oBAAoB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,OAAO;AACf;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH,WAAU,YAAY;AACtB;AACA;AACA;AACA;;AAEA,SAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,UAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAO,OAAO;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,sBAAsB,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,2BAA2B,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA,4CAA2C,+BAA+B,EAAE;AAC5E;AACA,IAAG;AACH,EAAC;;;AAGD;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED,EAAC;AACD;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH,EAAC;AACD;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA,qBAAoB,UAAU;;AAE9B;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;;AAEA,6BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA,+CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,WAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA,MAAK;AACL;;AAEA;;AAEA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW,iBAAiB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA,MAAK;AACL;;AAEA;;AAEA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAW,iBAAiB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,WAAU,QAAQ;AAClB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO,OAAO;AACd;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO,OAAO;AACd;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;;AAGD,0BAAyB,wBAAwB;;AAEjD;AACA;AACA;AACA,IAAG;;AAEH;AACA,kBAAiB,UAAU;;AAE3B;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAkB,aAAa;AAC/B;AACA;;AAEA;;AAEA;;AAEA,qBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAmB,SAAS;AAC5B;;AAEA;AACA;;AAEA;;AAEA,uBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAqB,gBAAgB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED,EAAC;AACD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,4CAA2C,oBAAoB,EAAE;AACjE,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,4CAA2C,oBAAoB,EAAE;AACjE,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,oBAAoB,EAAE;AACjE,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,sBAAqB,YAAY;AACjC;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,oBAAoB,EAAE;AACjE,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,aAAa;AACzD,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,YAAY;AACtB;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,4CAA2C,6BAA6B,EAAE;AAC1E,IAAG;;AAEH;AACA;AACA,4CAA2C,wBAAwB,EAAE;AACrE,IAAG;;AAEH;AACA;AACA,4CAA2C,wBAAwB,EAAE;AACrE,IAAG;;AAEH;AACA;AACA,4CAA2C,wBAAwB,EAAE;AACrE,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,gBAAgB;AAC1B;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA,qBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,WAAW;AACrB;AACA;AACA,oBAAmB,UAAU;AAC7B,kBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA,WAAU,WAAW;AACrB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA,uBAAsB,QAAQ;AAC9B,0BAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA,gCAA+B,aAAa;AAC5C;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA,gCAA+B,aAAa;AAC5C;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP,MAAK;AACL;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,WAAW;AACrB;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC,OAAO,WAAW,UAAU;AAC5D;AACA;AACA,qCAAoC,OAAO,WAAW,QAAQ,YAAY;AAC1E;AACA;AACA,QAAO;AACP,2CAA0C,6BAA6B;AACvE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA,UAAS;AACT,mBAAkB,OAAO;AACzB;AACA;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA,YAAW;AACX,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,SAAS,+BAA+B,SAAS;AACjE;AACA,iBAAgB,SAAS,+BAA+B,SAAS;AACjE;AACA;AACA,oCAAmC,SAAS;AAC5C,oDAAmD,SAAS;AAC5D,iCAAgC,SAAS;AACzC,oCAAmC,SAAS;AAC5C,oDAAmD,SAAS;AAC5D,iCAAgC,SAAS;AACzC,UAAS;AACT,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,KAAK,WAAW;AAC9C,+BAA8B,KAAK,WAAW;AAC9C;AACA;;AAEA;AACA,eAAc;AACd;;AAEA;;AAEA;AACA,eAAc;AACd;;;AAGA;AACA,kCAAiC,cAAc;AAC/C;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,QAAQ;AAClB;AACA;AACA,WAAU,WAAW;AACrB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,WAAW;AACrB;AACA;AACA,oBAAmB,WAAW;AAC9B;AACA;AACA;AACA,oBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC,kBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,4CAA2C,wBAAwB;AACnE,8CAA6C,uBAAuB;;AAEpE;AACA,oBAAmB,mBAAmB;AACtC,4BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,EAAC;;AAED,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAqD,uBAAuB;AAC5E,+DAA8D,cAAc;AAC5E;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,aAAa;AAChE,+BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU;AACV,EAAC;AACD;AACA;;AAEA;AACA,EAAC;;;;;;;ACxlJD;AACA;;AAEA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA,oBAAmB,mBAAmB;AACtC;AACA,wBAAuB,OAAO;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH,G;;;;;;AC3DA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,KAAK;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpIA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,KAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,IAAI;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,KAAK;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,IAAI;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,KAAK;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,KAAK;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,KAAK;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,KAAK;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,KAAK;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,KAAK;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACzhDA;AACA,2BAA0B,iCAAiC,kBAAkB,IAAI;AACjF;AACA;AACA;AACA;AACA;AACA,iBAAgB,QAAQ;AACxB;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,gBAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/MA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,IAAG;AACH;;AAEA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtkBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;;AAEA,kBAAiB,qBAAqB;AACtC,oBAAmB,wBAAwB;AAC3C;AACA;AACA,sBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C,+FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;;;;;;AClYA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;;;;;;AC9GA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,UAAU;AAC/B;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,sBAAqB,UAAU;AAC/B;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACpkCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA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","file":"formula-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"fs\"), require(\"path\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"fs\", \"path\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"formulaParser\"] = factory(require(\"fs\"), require(\"path\"));\n\telse\n\t\troot[\"formulaParser\"] = factory(root[\"fs\"], root[\"path\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_41__, __WEBPACK_EXTERNAL_MODULE_42__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 53b2117c969a4c36624b","import {Parser, SUPPORTED_FORMULAS} from './src/parser';\r\nimport {\r\n  default as error,\r\n  ERROR,\r\n  ERROR_DIV_ZERO,\r\n  ERROR_NAME,\r\n  ERROR_NOT_AVAILABLE,\r\n  ERROR_NULL,\r\n  ERROR_NUM,\r\n  ERROR_REF,\r\n  ERROR_VALUE\r\n} from './src/error';\r\nimport {\r\n  extractLabel,\r\n  toLabel,\r\n  columnIndexToLabel,\r\n  columnLabelToIndex,\r\n  rowIndexToLabel,\r\n  rowLabelToIndex\r\n} from './src/helper/cell';\r\n\r\nexport {\r\n  SUPPORTED_FORMULAS,\r\n  ERROR,\r\n  ERROR_DIV_ZERO,\r\n  ERROR_NAME,\r\n  ERROR_NOT_AVAILABLE,\r\n  ERROR_NULL,\r\n  ERROR_NUM,\r\n  ERROR_REF,\r\n  ERROR_VALUE,\r\n  Parser,\r\n  error,\r\n  extractLabel,\r\n  toLabel,\r\n  columnIndexToLabel,\r\n  columnLabelToIndex,\r\n  rowIndexToLabel,\r\n  rowLabelToIndex\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import Emitter from 'tiny-emitter';\r\nimport evaluateByOperator from './evaluate-by-operator/evaluate-by-operator';\r\nimport {Parser as GrammarParser} from './grammar-parser/grammar-parser';\r\nimport {trimEdges} from './helper/string';\r\nimport {toNumber, invertNumber} from './helper/number';\r\nimport {default as errorParser, isValidStrict as isErrorValid, ERROR, ERROR_NAME} from './error';\r\nimport {extractLabel, toLabel} from './helper/cell';\r\n\r\nexport {default as SUPPORTED_FORMULAS} from './supported-formulas';\r\n\r\n/**\r\n * @class Parser\r\n */\r\nclass Parser extends Emitter {\r\n  constructor() {\r\n    super();\r\n    this.parser = new GrammarParser();\r\n    this.parser.yy = {\r\n      toNumber,\r\n      trimEdges,\r\n      invertNumber,\r\n      throwError: (errorName) => this._throwError(errorName),\r\n      callVariable: (variable) => this._callVariable(variable),\r\n      evaluateByOperator,\r\n      callFunction: evaluateByOperator,\r\n      cellValue: (value, sheet) => this._callCellValue(value, sheet),\r\n      rangeValue: (start, end, sheet) => this._callRangeValue(start, end, sheet),\r\n    };\r\n    this.variables = Object.create(null);\r\n\r\n    this\r\n      .setVariable('TRUE', true)\r\n      .setVariable('FALSE', false)\r\n      .setVariable('NULL', null);\r\n  }\r\n\r\n  /**\r\n   * Parse formula expression.\r\n   *\r\n   * @param {String} expression to parse.\r\n   * @return {*} Returns an object with tow properties `error` and `result`.\r\n   */\r\n  parse(expression) {\r\n    let result = null;\r\n    let error = null;\r\n\r\n    try {\r\n      if (expression === '') {\r\n        result = '';\r\n      } else {\r\n        result = this.parser.parse(expression);\r\n      }\r\n    } catch (ex) {\r\n      const message = errorParser(ex.message);\r\n\r\n      if (message) {\r\n        error = message;\r\n      } else {\r\n        error = errorParser(ERROR);\r\n      }\r\n    }\r\n\r\n    if (result instanceof Error) {\r\n      error = errorParser(result.message) || errorParser(ERROR);\r\n      result = null;\r\n    }\r\n\r\n    return {\r\n      error: error,\r\n      result: result\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set predefined variable name which can be visible while parsing formula expression.\r\n   *\r\n   * @param {String} name Variable name.\r\n   * @param {*} value Variable value.\r\n   * @returns {Parser}\r\n   */\r\n  setVariable(name, value) {\r\n    this.variables[name] = value;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get variable name.\r\n   *\r\n   * @param {String} name Variable name.\r\n   * @returns {*}\r\n   */\r\n  getVariable(name) {\r\n    return this.variables[name];\r\n  }\r\n\r\n  /**\r\n   * Retrieve variable value by its name.\r\n   *\r\n   * @param name Variable name.\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _callVariable(name) {\r\n    let value = this.getVariable(name);\r\n\r\n    this.emit('callVariable', name, (newValue) => {\r\n      if (newValue !== void 0) {\r\n        value = newValue;\r\n      }\r\n    });\r\n\r\n    if (value === void 0) {\r\n      throw Error(ERROR_NAME);\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Retrieve value by its label (`B3`, `B$3`, `B$3`, `$B$3`).\r\n   *\r\n   * @param {String} label Coordinates.\r\n   * @param {String} sheet Reference sheet name\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _callCellValue(label, sheet) {\r\n    label = label.toUpperCase();\r\n    const [row, column] = extractLabel(label);\r\n    let value = void 0;\r\n\r\n    let cellCoordinate = sheet ? {label, row, column, sheet} : {label, row, column};\r\n\r\n    this.emit('callCellValue', cellCoordinate, (_value) => {\r\n      value = _value;\r\n    });\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Retrieve value by its label (`B3:A1`, `B$3:A1`, `B$3:$A1`, `$B$3:A$1`).\r\n   *\r\n   * @param {String} startLabel Coordinates of the first cell.\r\n   * @param {String} endLabel Coordinates of the last cell.\r\n   * @param {String} sheet Reference sheet name\r\n   * @returns {Array} Returns an array of mixed values.\r\n   * @private\r\n   */\r\n  _callRangeValue(startLabel, endLabel, sheet) {\r\n    startLabel = startLabel.toUpperCase();\r\n    endLabel = endLabel.toUpperCase();\r\n\r\n    const [startRow, startColumn] = extractLabel(startLabel);\r\n    const [endRow, endColumn] = extractLabel(endLabel);\r\n    let startCell = {};\r\n    let endCell = {};\r\n\r\n    if (startRow.index <= endRow.index) {\r\n      startCell.row = startRow;\r\n      endCell.row = endRow;\r\n    } else {\r\n      startCell.row = endRow;\r\n      endCell.row = startRow;\r\n    }\r\n\r\n    if (startColumn.index <= endColumn.index) {\r\n      startCell.column = startColumn;\r\n      endCell.column = endColumn;\r\n    } else {\r\n      startCell.column = endColumn;\r\n      endCell.column = startColumn;\r\n    }\r\n\r\n    startCell.label = toLabel(startCell.row, startCell.column);\r\n    endCell.label = toLabel(endCell.row, endCell.column);\r\n\r\n    if (sheet) {\r\n      startCell.sheet = sheet;\r\n      endCell.sheet = sheet;\r\n    }\r\n\r\n    let value = [];\r\n\r\n    this.emit('callRangeValue', startCell, endCell, (_value = []) => {\r\n      value = _value;\r\n    });\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Try to throw error by its name.\r\n   *\r\n   * @param {String} errorName Error name.\r\n   * @returns {String}\r\n   * @private\r\n   */\r\n  _throwError(errorName) {\r\n    if (isErrorValid(errorName)) {\r\n      throw Error(errorName);\r\n    }\r\n\r\n    throw Error(ERROR);\r\n  }\r\n}\r\n\r\nexport {Parser};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","const SUPPORTED_FORMULAS = [\r\n  'ABS',\r\n  'ACCRINT',\r\n  'ACOS',\r\n  'ACOSH',\r\n  'ACOT',\r\n  'ACOTH',\r\n  'ADD',\r\n  'AGGREGATE',\r\n  'AND',\r\n  'ARABIC',\r\n  'ARGS2ARRAY',\r\n  'ASIN',\r\n  'ASINH',\r\n  'ATAN',\r\n  'ATAN2',\r\n  'ATANH',\r\n  'AVEDEV',\r\n  'AVERAGE',\r\n  'AVERAGEA',\r\n  'AVERAGEIF',\r\n  'AVERAGEIFS',\r\n  'BASE',\r\n  'BESSELI',\r\n  'BESSELJ',\r\n  'BESSELK',\r\n  'BESSELY',\r\n  'BETA.DIST',\r\n  'BETA.INV',\r\n  'BETADIST',\r\n  'BETAINV',\r\n  'BIN2DEC',\r\n  'BIN2HEX',\r\n  'BIN2OCT',\r\n  'BINOM.DIST',\r\n  'BINOM.DIST.RANGE',\r\n  'BINOM.INV',\r\n  'BINOMDIST',\r\n  'BITAND',\r\n  'BITLSHIFT',\r\n  'BITOR',\r\n  'BITRSHIFT',\r\n  'BITXOR',\r\n  'CEILING',\r\n  'CEILINGMATH',\r\n  'CEILINGPRECISE',\r\n  'CHAR',\r\n  'CHISQ.DIST',\r\n  'CHISQ.DIST.RT',\r\n  'CHISQ.INV',\r\n  'CHISQ.INV.RT',\r\n  'CHOOSE',\r\n  'CHOOSE',\r\n  'CLEAN',\r\n  'CODE',\r\n  'COLUMN',\r\n  'COLUMNS',\r\n  'COMBIN',\r\n  'COMBINA',\r\n  'COMPLEX',\r\n  'CONCATENATE',\r\n  'CONFIDENCE',\r\n  'CONFIDENCE.NORM',\r\n  'CONFIDENCE.T',\r\n  'CONVERT',\r\n  'CORREL',\r\n  'COS',\r\n  'COSH',\r\n  'COT',\r\n  'COTH',\r\n  'COUNT',\r\n  'COUNTA',\r\n  'COUNTBLANK',\r\n  'COUNTIF',\r\n  'COUNTIFS',\r\n  'COUNTIN',\r\n  'COUNTUNIQUE',\r\n  'COVARIANCE.P',\r\n  'COVARIANCE.S',\r\n  'CSC',\r\n  'CSCH',\r\n  'CUMIPMT',\r\n  'CUMPRINC',\r\n  'DATE',\r\n  'DATEDIF',\r\n  'DATEVALUE',\r\n  'DAY',\r\n  'DAYS',\r\n  'DAYS360',\r\n  'DB',\r\n  'DDB',\r\n  'DEC2BIN',\r\n  'DEC2HEX',\r\n  'DEC2OCT',\r\n  'DECIMAL',\r\n  'DEGREES',\r\n  'DELTA',\r\n  'DEVSQ',\r\n  'DIVIDE',\r\n  'DOLLAR',\r\n  'DOLLARDE',\r\n  'DOLLARFR',\r\n  'E',\r\n  'EDATE',\r\n  'EFFECT',\r\n  'EOMONTH',\r\n  'EQ',\r\n  'ERF',\r\n  'ERFC',\r\n  'EVEN',\r\n  'EXACT',\r\n  'EXPON.DIST',\r\n  'EXPONDIST',\r\n  'F.DIST',\r\n  'F.DIST.RT',\r\n  'F.INV',\r\n  'F.INV.RT',\r\n  'FACT',\r\n  'FACTDOUBLE',\r\n  'FALSE',\r\n  'FDIST',\r\n  'FDISTRT',\r\n  'FIND',\r\n  'FINV',\r\n  'FINVRT',\r\n  'FISHER',\r\n  'FISHERINV',\r\n  'FIXED',\r\n  'FLATTEN',\r\n  'FLOOR',\r\n  'FORECAST',\r\n  'FREQUENCY',\r\n  'FV',\r\n  'FVSCHEDULE',\r\n  'GAMMA',\r\n  'GAMMA.DIST',\r\n  'GAMMA.INV',\r\n  'GAMMADIST',\r\n  'GAMMAINV',\r\n  'GAMMALN',\r\n  'GAMMALN.PRECISE',\r\n  'GAUSS',\r\n  'GCD',\r\n  'GEOMEAN',\r\n  'GESTEP',\r\n  'GROWTH',\r\n  'GTE',\r\n  'HARMEAN',\r\n  'HEX2BIN',\r\n  'HEX2DEC',\r\n  'HEX2OCT',\r\n  'HOUR',\r\n  'HTML2TEXT',\r\n  'HYPGEOM.DIST',\r\n  'HYPGEOMDIST',\r\n  'IF',\r\n  'IMABS',\r\n  'IMAGINARY',\r\n  'IMARGUMENT',\r\n  'IMCONJUGATE',\r\n  'IMCOS',\r\n  'IMCOSH',\r\n  'IMCOT',\r\n  'IMCSC',\r\n  'IMCSCH',\r\n  'IMDIV',\r\n  'IMEXP',\r\n  'IMLN',\r\n  'IMLOG10',\r\n  'IMLOG2',\r\n  'IMPOWER',\r\n  'IMPRODUCT',\r\n  'IMREAL',\r\n  'IMSEC',\r\n  'IMSECH',\r\n  'IMSIN',\r\n  'IMSINH',\r\n  'IMSQRT',\r\n  'IMSUB',\r\n  'IMSUM',\r\n  'IMTAN',\r\n  'INDEX',\r\n  'INT',\r\n  'INTERCEPT',\r\n  'INTERVAL',\r\n  'IPMT',\r\n  'IRR',\r\n  'ISBINARY',\r\n  'ISBLANK',\r\n  'ISEVEN',\r\n  'ISLOGICAL',\r\n  'ISNA',\r\n  'ISNONTEXT',\r\n  'ISNUMBER',\r\n  'ISODD',\r\n  'ISODD',\r\n  'ISOWEEKNUM',\r\n  'ISPMT',\r\n  'ISTEXT',\r\n  'JOIN',\r\n  'KURT',\r\n  'LARGE',\r\n  'LCM',\r\n  'LEFT',\r\n  'LEN',\r\n  'LINEST',\r\n  'LN',\r\n  'LOG',\r\n  'LOG10',\r\n  'LOGEST',\r\n  'LOGNORM.DIST',\r\n  'LOGNORM.INV',\r\n  'LOGNORMDIST',\r\n  'LOGNORMINV',\r\n  'LOOKUP',\r\n  'LOWER',\r\n  'LT',\r\n  'LTE',\r\n  'MATCH',\r\n  'MAX',\r\n  'MAXA',\r\n  'MEDIAN',\r\n  'MID',\r\n  'MIN',\r\n  'MINA',\r\n  'MINUS',\r\n  'MINUTE',\r\n  'MIRR',\r\n  'MOD',\r\n  'MODE.MULT',\r\n  'MODE.SNGL',\r\n  'MODEMULT',\r\n  'MODESNGL',\r\n  'MONTH',\r\n  'MROUND',\r\n  'MULTINOMIAL',\r\n  'MULTIPLY',\r\n  'NA',\r\n  'NE',\r\n  'NEGBINOM.DIST',\r\n  'NEGBINOMDIST',\r\n  'NETWORKDAYS',\r\n  'NOMINAL',\r\n  'NORM.DIST',\r\n  'NORM.INV',\r\n  'NORM.S.DIST',\r\n  'NORM.S.INV',\r\n  'NORMDIST',\r\n  'NORMINV',\r\n  'NORMSDIST',\r\n  'NORMSINV',\r\n  'NOT',\r\n  'NOW',\r\n  'NPER',\r\n  'NPV',\r\n  'NUMBERS',\r\n  'NUMERAL',\r\n  'OCT2BIN',\r\n  'OCT2DEC',\r\n  'OCT2HEX',\r\n  'ODD',\r\n  'OR',\r\n  'PDURATION',\r\n  'PEARSON',\r\n  'PERCENTILEEXC',\r\n  'PERCENTILEINC',\r\n  'PERCENTRANKEXC',\r\n  'PERCENTRANKINC',\r\n  'PERMUT',\r\n  'PERMUTATIONA',\r\n  'PHI',\r\n  'PI',\r\n  'PMT',\r\n  'POISSON.DIST',\r\n  'POISSONDIST',\r\n  'POW',\r\n  'POWER',\r\n  'PPMT',\r\n  'PROB',\r\n  'PRODUCT',\r\n  'PROPER',\r\n  'PV',\r\n  'QUARTILE.EXC',\r\n  'QUARTILE.INC',\r\n  'QUARTILEEXC',\r\n  'QUARTILEINC',\r\n  'QUOTIENT',\r\n  'RADIANS',\r\n  'RAND',\r\n  'RANDBETWEEN',\r\n  'RANK.AVG',\r\n  'RANK.EQ',\r\n  'RANKAVG',\r\n  'RANKEQ',\r\n  'RATE',\r\n  'REFERENCE',\r\n  'REGEXEXTRACT',\r\n  'REGEXMATCH',\r\n  'REGEXREPLACE',\r\n  'REPLACE',\r\n  'REPT',\r\n  'RIGHT',\r\n  'ROMAN',\r\n  'ROUND',\r\n  'ROUNDDOWN',\r\n  'ROUNDUP',\r\n  'ROW',\r\n  'ROWS',\r\n  'RRI',\r\n  'RSQ',\r\n  'SEARCH',\r\n  'SEC',\r\n  'SECH',\r\n  'SECOND',\r\n  'SERIESSUM',\r\n  'SIGN',\r\n  'SIN',\r\n  'SINH',\r\n  'SKEW',\r\n  'SKEW.P',\r\n  'SKEWP',\r\n  'SLN',\r\n  'SLOPE',\r\n  'SMALL',\r\n  'SPLIT',\r\n  'SPLIT',\r\n  'SQRT',\r\n  'SQRTPI',\r\n  'STANDARDIZE',\r\n  'STDEV.P',\r\n  'STDEV.S',\r\n  'STDEVA',\r\n  'STDEVP',\r\n  'STDEVPA',\r\n  'STDEVS',\r\n  'STEYX',\r\n  'SUBSTITUTE',\r\n  'SUBTOTAL',\r\n  'SUM',\r\n  'SUMIF',\r\n  'SUMIFS',\r\n  'SUMPRODUCT',\r\n  'SUMSQ',\r\n  'SUMX2MY2',\r\n  'SUMX2PY2',\r\n  'SUMXMY2',\r\n  'SWITCH',\r\n  'SYD',\r\n  'T',\r\n  'T.DIST',\r\n  'T.DIST.2T',\r\n  'T.DIST.RT',\r\n  'T.INV',\r\n  'T.INV.2T',\r\n  'TAN',\r\n  'TANH',\r\n  'TBILLEQ',\r\n  'TBILLPRICE',\r\n  'TBILLYIELD',\r\n  'TDIST',\r\n  'TDIST2T',\r\n  'TDISTRT',\r\n  'TEXT',\r\n  'TIME',\r\n  'TIMEVALUE',\r\n  'TINV',\r\n  'TINV2T',\r\n  'TODAY',\r\n  'TRANSPOSE',\r\n  'TREND',\r\n  'TRIM',\r\n  'TRIMMEAN',\r\n  'TRUE',\r\n  'TRUNC',\r\n  'UNICHAR',\r\n  'UNICODE',\r\n  'UNIQUE',\r\n  'UPPER',\r\n  'VALUE',\r\n  'VAR.P',\r\n  'VAR.S',\r\n  'VARA',\r\n  'VARP',\r\n  'VARPA',\r\n  'VARS',\r\n  'WEEKDAY',\r\n  'WEEKNUM',\r\n  'WEIBULL.DIST',\r\n  'WEIBULLDIST',\r\n  'WORKDAY',\r\n  'XIRR',\r\n  'XNPV',\r\n  'XOR',\r\n  'YEAR',\r\n  'YEARFRAC',\r\n  'VLOOKUP',\r\n  'HLOOKUP',\r\n  'IFERROR',\r\n  'IFNA'\r\n];\r\n\r\nexport {SUPPORTED_FORMULAS as default};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/supported-formulas.js","function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tiny-emitter/index.js\n// module id = 3\n// module chunks = 0","import {default as add} from './operator/add';\r\nimport {default as ampersand} from './operator/ampersand';\r\nimport {default as divide} from './operator/divide';\r\nimport {default as equal} from './operator/equal';\r\nimport {default as formulaFunction} from './operator/formula-function';\r\nimport {default as greaterThan} from './operator/greater-than';\r\nimport {default as greaterThanOrEqual} from './operator/greater-than-or-equal';\r\nimport {default as lessThan} from './operator/less-than';\r\nimport {default as lessThanOrEqual} from './operator/less-than-or-equal';\r\nimport {default as minus} from './operator/minus';\r\nimport {default as multiply} from './operator/multiply';\r\nimport {default as notEqual} from './operator/not-equal';\r\nimport {default as power} from './operator/power';\r\nimport {ERROR_NAME} from './../error';\r\nimport Decimal from 'decimal.js';\r\n\r\nconst availableOperators = Object.create(null);\r\n\r\n// Configuration\r\n\r\nDecimal.set({ precision: 15 });\r\n\r\nregisterOperation(add.SYMBOL, add);\r\nregisterOperation(ampersand.SYMBOL, ampersand);\r\nregisterOperation(divide.SYMBOL, divide);\r\nregisterOperation(equal.SYMBOL, equal);\r\nregisterOperation(power.SYMBOL, power);\r\nregisterOperation(formulaFunction.SYMBOL, formulaFunction);\r\nregisterOperation(greaterThan.SYMBOL, greaterThan);\r\nregisterOperation(greaterThanOrEqual.SYMBOL, greaterThanOrEqual);\r\nregisterOperation(lessThan.SYMBOL, lessThan);\r\nregisterOperation(lessThanOrEqual.SYMBOL, lessThanOrEqual);\r\nregisterOperation(multiply.SYMBOL, multiply);\r\nregisterOperation(notEqual.SYMBOL, notEqual);\r\nregisterOperation(minus.SYMBOL, minus);\r\n\r\n/**\r\n * Evaluate values by operator id.git\r\n *\r\n * @param {String} operator Operator id.\r\n * @param {Array} [params=[]] Arguments to evaluate.\r\n * @returns {*}\r\n */\r\nexport default function evaluateByOperator(operator, params = []) {\r\n  operator = operator.toUpperCase();\r\n\r\n  if (!availableOperators[operator]) {\r\n    throw Error(ERROR_NAME);\r\n  }\r\n\r\n  return availableOperators[operator](...params);\r\n}\r\n\r\n/**\r\n * Register operator.\r\n *\r\n * @param {String|Array} symbol Symbol to register.\r\n * @param {Function} func Logic to register for this symbol.\r\n */\r\nexport function registerOperation(symbol, func) {\r\n  if (!Array.isArray(symbol)) {\r\n    symbol = [symbol.toUpperCase()];\r\n  }\r\n  symbol.forEach((s) => {\r\n    if (func.isFactory) {\r\n      availableOperators[s] = func(s);\r\n    } else {\r\n      availableOperators[s] = func;\r\n    }\r\n  });\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/evaluate-by-operator.js","import {toNumber} from './../../helper/number';\r\nimport {ERROR_VALUE} from './../../error';\r\nimport {undefinedCell} from './../../helper/undefined-cell';\r\nimport Decimal from 'decimal.js';\r\n\r\nexport const SYMBOL = '+';\r\n\r\nexport default function func(first, ...rest) {\r\n  try {\r\n    first = undefinedCell(first);\r\n\r\n    for (var i = 0; i < rest.length; i++) {\r\n      rest[i] = undefinedCell(rest[i]);\r\n    }\r\n\r\n    const result = rest.reduce((acc, value) => {\r\n      return (new Decimal(acc)).plus(new Decimal(value)).toNumber();\r\n    }, first);\r\n\r\n    if (isNaN(result)) {\r\n      throw Error(ERROR_VALUE);\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    throw Error(ERROR_VALUE);\r\n  }\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/add.js","/**\r\n * Convert value into number.\r\n *\r\n * @param {String|Number} number\r\n * @returns {*}\r\n */\r\nexport function toNumber(number) {\r\n  let result;\r\n\r\n  if (typeof number === 'number') {\r\n    result = number;\r\n\r\n  } else if (typeof number === 'string') {\r\n    result = number.indexOf('.') > -1 ? parseFloat(number) : parseInt(number, 10);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Invert provided number.\r\n *\r\n * @param {Number} number\r\n * @returns {Number} Returns inverted number.\r\n */\r\nexport function invertNumber(number) {\r\n  return -1 * toNumber(number);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper/number.js","export const ERROR = 'ERROR';\r\nexport const ERROR_DIV_ZERO = 'DIV/0';\r\nexport const ERROR_NAME = 'NAME';\r\nexport const ERROR_NOT_AVAILABLE = 'N/A';\r\nexport const ERROR_NULL = 'NULL';\r\nexport const ERROR_NUM = 'NUM';\r\nexport const ERROR_REF = 'REF';\r\nexport const ERROR_VALUE = 'VALUE';\r\n\r\nconst errors = {\r\n  [ERROR]: '#ERROR!',\r\n  [ERROR_DIV_ZERO]: '#DIV/0!',\r\n  [ERROR_NAME]: '#NAME?',\r\n  [ERROR_NOT_AVAILABLE]: '#N/A',\r\n  [ERROR_NULL]: '#NULL!',\r\n  [ERROR_NUM]: '#NUM!',\r\n  [ERROR_REF]: '#REF!',\r\n  [ERROR_VALUE]: '#VALUE!',\r\n};\r\n\r\n/**\r\n * Return error type based on provided error id.\r\n *\r\n * @param {String} type Error type.\r\n * @returns {String|null} Returns error id.\r\n */\r\nexport default function error(type) {\r\n  let error;\r\n\r\n  type = (type + '').replace(/#|!|\\?/g, '');\r\n\r\n  if (errors[type]) {\r\n    error = errors[type];\r\n  }\r\n\r\n  return error ? error : null;\r\n}\r\n\r\n/**\r\n * Check if error type is strict valid with knows errors.\r\n *\r\n * @param {String} Error type.\r\n * @return {Boolean}\r\n */\r\nexport function isValidStrict(type) {\r\n  let valid = false;\r\n\r\n  for (var i in errors) {\r\n    if (errors.hasOwnProperty(i) && errors[i] === type) {\r\n      valid = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return valid;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/error.js","export function undefinedCell(value) {\r\n  if (value === undefined || value === '' || value === true) {\r\n    return 0;\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper/undefined-cell.js","/*! decimal.js v7.5.1 https://github.com/MikeMcl/decimal.js/LICENCE */\r\n;(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*\r\n   *  decimal.js v7.5.1\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    Decimal = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = {};\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * Math.pow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = Math.pow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = Math.pow(4, -k).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(Math.pow(5, -k));\r\n\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is Infinity.\r\n      // Return x if both are Infinity with different signs.\r\n      // Return NaN if both are Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or 0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is Infinity or x is 0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is Infinity.\r\n      // Return x if both are Infinity with the same sign.\r\n      // Return NaN if both are Infinity with different signs.\r\n      // Return y if x is finite and y is Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '1e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, Infinity or 0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.\r\n        ? NaN\r\n\r\n        // Return Infinity if either is Infinity.\r\n        // Return 0 if either is 0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of the magnitude of `y` to the value\r\n   * of this Decimal.\r\n   *\r\n   * If the value of this Decimal is equidistant from two multiples of `y`, the rounding mode `rm`,\r\n   * or `Decimal.rounding` if `rm` is omitted, determines the direction of the nearest multiple.\r\n   *\r\n   * In the context of this method, rounding mode 4 (ROUND_HALF_UP) is the same as rounding mode 0\r\n   * (ROUND_UP), and so on.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm !== void 0) checkInt32(rm, 0, 8);\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      if (rm < 4) rm = [4, 5, 7, 8][rm];\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, 0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either Infinity, NaN or 0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n  // Add aliases to match BigDecimal method names.\r\n  // P.add = P.plus;\r\n  P.subtract = P.minus;\r\n  P.multiply = P.times;\r\n  P.divide = P.div;\r\n  P.remainder = P.mod;\r\n  P.compareTo = P.cmp;\r\n  P.negate = P.neg;\r\n   */\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, y,\r\n      len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = Math.pow(4, -k).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? Math.pow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) return taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    // Max k before Math.pow precision loss is 22\r\n    x = x.times(Math.pow(5, -k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(0, -0)               = pi\r\n   * atan2(0, +0)               = 0\r\n   * atan2(0, -x)               = pi for x > 0\r\n   * atan2(0, x)                = 0 for x > 0\r\n   * atan2(-y, 0)               = -pi/2 for y > 0\r\n   * atan2(y, 0)                = pi/2 for y > 0\r\n   * atan2(y, -Infinity)        = pi for finite y > 0\r\n   * atan2(y, +Infinity)        = 0 for finite y > 0\r\n   * atan2(Infinity, x)         = pi/2 for finite x\r\n   * atan2(Infinity, -Infinity) = 3*pi/4\r\n   * atan2(Infinity, +Infinity) = pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is Infinity or y is 0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is Infinity or x is 0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if ((v = obj[p = ps[i]]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if ((v = obj[p = 'crypto']) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (v instanceof Decimal) {\r\n        x.s = v.s;\r\n        x.e = v.e;\r\n        x.d = (v = v.d) ? v.slice() : v;\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n          x.e = e;\r\n          x.d = [v];\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if (v.charCodeAt(0) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(Decimal);\r\n\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self\r\n        ? self : Function('return this')();\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/decimal.js/decimal.js\n// module id = 9\n// module chunks = 0","export const SYMBOL = '&';\r\n\r\nexport default function func(...params) {\r\n  return params.reduce((acc, value) => acc + value.toString(), '');\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/ampersand.js","import { toNumber } from './../../helper/number';\r\nimport { ERROR_DIV_ZERO, ERROR_VALUE } from './../../error';\r\nimport {undefinedCell} from './../../helper/undefined-cell';\r\nimport Decimal from 'decimal.js';\r\n\r\nexport const SYMBOL = '/';\r\n\r\nexport default function func(first, ...rest) {\r\n  try {\r\n    first = undefinedCell(first);\r\n\r\n    for (var i = 0; i < rest.length; i++) {\r\n      rest[i] = undefinedCell(rest[i]);\r\n      if (rest[i] === 0) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    const result = rest.reduce((acc, value) => {\r\n      const tempValue = (new Decimal(acc)).div(new Decimal(toNumber(value))).toNumber();\r\n      if (tempValue === Infinity || tempValue === -Infinity) {\r\n        throw Error(ERROR_DIV_ZERO);\r\n      }\r\n\r\n      return tempValue;\r\n    }, toNumber(first));\r\n\r\n    if (isNaN(result)) {\r\n      throw Error(ERROR_VALUE);\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    if (error.message === ERROR_DIV_ZERO) {\r\n      throw Error(ERROR_DIV_ZERO);\r\n    }\r\n\r\n    throw Error(ERROR_VALUE);\r\n  }\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/divide.js","export const SYMBOL = '=';\r\n\r\nexport default function func(exp1, exp2) {\r\n  if ((typeof exp1 === 'string') && (typeof exp2 === 'string')) {\r\n    return exp1.toUpperCase() === exp2.toUpperCase();\r\n  } else if ((exp1 == false || exp1 === undefined) && (exp2 == false || exp2 === undefined)) {\r\n    return true;\r\n  } else {\r\n    return exp1 === exp2;\r\n  }\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/equal.js","import SUPPORTED_FORMULAS from './../../supported-formulas';\r\nimport {ERROR_NAME} from './../../error';\r\nimport * as formulajs from 'formulajs';\r\n\r\nexport const SYMBOL = SUPPORTED_FORMULAS;\r\n\r\nexport default function func(symbol) {\r\n  return function(...params) {\r\n    symbol = symbol.toUpperCase();\r\n\r\n    const symbolParts = symbol.split('.');\r\n    let foundFormula = false;\r\n    let result;\r\n\r\n    if (symbolParts.length === 1) {\r\n      if (formulajs[symbolParts[0]]) {\r\n        foundFormula = true;\r\n        result = formulajs[symbolParts[0]](...params);\r\n      }\r\n    } else {\r\n      const length = symbolParts.length;\r\n      let index = 0;\r\n      let nestedFormula = formulajs;\r\n\r\n      while (index < length) {\r\n        nestedFormula = nestedFormula[symbolParts[index]];\r\n        index++;\r\n\r\n        if (!nestedFormula) {\r\n          nestedFormula = null;\r\n          break;\r\n        }\r\n      }\r\n      if (nestedFormula) {\r\n        foundFormula = true;\r\n        result = nestedFormula(...params);\r\n      }\r\n    }\r\n\r\n    if (!foundFormula) {\r\n      throw Error(ERROR_NAME);\r\n    }\r\n\r\n    return result;\r\n  };\r\n};\r\n\r\nfunc.isFactory = true;\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/formula-function.js","var categories = [\r\n  require('./lib/compatibility'),\r\n  require('./lib/database'),\r\n  require('./lib/engineering'),\r\n  require('./lib/logical'),\r\n  require('./lib/math-trig'),\r\n  require('./lib/text'),\r\n  require('./lib/date-time'),\r\n  require('./lib/financial'),\r\n  require('./lib/information'),\r\n  require('./lib/lookup-reference'),\r\n  require('./lib/statistical'),\r\n  require('./lib/miscellaneous')\r\n];\r\n\r\nfor (var c in categories) {\r\n  var category = categories[c];\r\n  for (var f in category) {\r\n    exports[f] = exports[f] || category[f];\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/index.js\n// module id = 14\n// module chunks = 0","var mathTrig = require('./math-trig');\r\nvar statistical = require('./statistical');\r\nvar engineering = require('./engineering');\r\nvar dateTime = require('./date-time');\r\n\r\nfunction set(fn, root) {\r\n  if (root) {\r\n    for (var i in root) {\r\n      fn[i] = root[i];\r\n    }\r\n  }\r\n\r\n  return fn;\r\n}\r\n\r\nexports.BETADIST = statistical.BETA.DIST;\r\nexports.BETAINV = statistical.BETA.INV;\r\nexports.BINOMDIST = statistical.BINOM.DIST;\r\nexports.CEILING = exports.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);\r\nexports.CEILINGMATH = mathTrig.CEILING.MATH;\r\nexports.CEILINGPRECISE = mathTrig.CEILING.PRECISE;\r\nexports.CHIDIST = statistical.CHISQ.DIST;\r\nexports.CHIDISTRT = statistical.CHISQ.DIST.RT;\r\nexports.CHIINV = statistical.CHISQ.INV;\r\nexports.CHIINVRT = statistical.CHISQ.INV.RT;\r\nexports.CHITEST = statistical.CHISQ.TEST;\r\nexports.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);\r\nexports.COVAR = statistical.COVARIANCE.P;\r\nexports.COVARIANCEP = statistical.COVARIANCE.P;\r\nexports.COVARIANCES = statistical.COVARIANCE.S;\r\nexports.CRITBINOM = statistical.BINOM.INV;\r\nexports.EXPONDIST = statistical.EXPON.DIST;\r\nexports.ERFCPRECISE = engineering.ERFC.PRECISE;\r\nexports.ERFPRECISE = engineering.ERF.PRECISE;\r\nexports.FDIST = statistical.F.DIST;\r\nexports.FDISTRT = statistical.F.DIST.RT;\r\nexports.FINVRT = statistical.F.INV.RT;\r\nexports.FINV = statistical.F.INV;\r\nexports.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);\r\nexports.FLOORMATH = mathTrig.FLOOR.MATH;\r\nexports.FLOORPRECISE = mathTrig.FLOOR.PRECISE;\r\nexports.FTEST = statistical.F.TEST;\r\nexports.GAMMADIST = statistical.GAMMA.DIST;\r\nexports.GAMMAINV = statistical.GAMMA.INV;\r\nexports.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;\r\nexports.HYPGEOMDIST = statistical.HYPGEOM.DIST;\r\nexports.LOGINV = statistical.LOGNORM.INV;\r\nexports.LOGNORMINV = statistical.LOGNORM.INV;\r\nexports.LOGNORMDIST = statistical.LOGNORM.DIST;\r\nexports.MODE = set(statistical.MODE.SNGL, statistical.MODE);\r\nexports.MODEMULT = statistical.MODE.MULT;\r\nexports.MODESNGL = statistical.MODE.SNGL;\r\nexports.NEGBINOMDIST = statistical.NEGBINOM.DIST;\r\nexports.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;\r\nexports.NORMDIST = statistical.NORM.DIST;\r\nexports.NORMINV = statistical.NORM.INV;\r\nexports.NORMSDIST = statistical.NORM.S.DIST;\r\nexports.NORMSINV = statistical.NORM.S.INV;\r\nexports.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);\r\nexports.PERCENTILEEXC = statistical.PERCENTILE.EXC;\r\nexports.PERCENTILEINC = statistical.PERCENTILE.INC;\r\nexports.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);\r\nexports.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;\r\nexports.PERCENTRANKINC = statistical.PERCENTRANK.INC;\r\nexports.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);\r\nexports.POISSONDIST = statistical.POISSON.DIST;\r\nexports.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);\r\nexports.QUARTILEEXC = statistical.QUARTILE.EXC;\r\nexports.QUARTILEINC = statistical.QUARTILE.INC;\r\nexports.RANK = set(statistical.RANK.EQ, statistical.RANK);\r\nexports.RANKAVG = statistical.RANK.AVG;\r\nexports.RANKEQ = statistical.RANK.EQ;\r\nexports.SKEWP = statistical.SKEW.P;\r\nexports.STDEV = set(statistical.STDEV.S, statistical.STDEV);\r\nexports.STDEVP = statistical.STDEV.P;\r\nexports.STDEVS = statistical.STDEV.S;\r\nexports.TDIST = statistical.T.DIST;\r\nexports.TDISTRT = statistical.T.DIST.RT;\r\nexports.TINV = statistical.T.INV;\r\nexports.TTEST = statistical.T.TEST;\r\nexports.VAR = set(statistical.VAR.S, statistical.VAR);\r\nexports.VARP = statistical.VAR.P;\r\nexports.VARS = statistical.VAR.S;\r\nexports.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);\r\nexports.WEIBULLDIST = statistical.WEIBULL.DIST;\r\nexports.WORKDAYINTL = dateTime.WORKDAY.INTL;\r\nexports.ZTEST = statistical.Z.TEST;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/compatibility.js\n// module id = 15\n// module chunks = 0","var utils = require('./utils');\r\nvar error = require('./error');\r\nvar statistical = require('./statistical');\r\nvar information = require('./information');\r\n\r\nexports.ABS = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = Math.abs(number);\r\n\r\n  return result;\r\n};\r\n\r\nexports.ACOS = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = Math.acos(number);\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.ACOSH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = Math.log(number + Math.sqrt(number * number - 1));\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.ACOT = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = Math.atan(1 / number);\r\n\r\n  return result;\r\n};\r\n\r\nexports.ACOTH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = 0.5 * Math.log((number + 1) / (number - 1));\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n//TODO: use options\r\nexports.AGGREGATE = function(function_num, options, ref1, ref2) {\r\n  function_num = utils.parseNumber(function_num);\r\n  options = utils.parseNumber(function_num);\r\n  if (utils.anyIsError(function_num, options)) {\r\n    return error.value;\r\n  }\r\n  switch (function_num) {\r\n    case 1:\r\n      return statistical.AVERAGE(ref1);\r\n    case 2:\r\n      return statistical.COUNT(ref1);\r\n    case 3:\r\n      return statistical.COUNTA(ref1);\r\n    case 4:\r\n      return statistical.MAX(ref1);\r\n    case 5:\r\n      return statistical.MIN(ref1);\r\n    case 6:\r\n      return exports.PRODUCT(ref1);\r\n    case 7:\r\n      return statistical.STDEV.S(ref1);\r\n    case 8:\r\n      return statistical.STDEV.P(ref1);\r\n    case 9:\r\n      return exports.SUM(ref1);\r\n    case 10:\r\n      return statistical.VAR.S(ref1);\r\n    case 11:\r\n      return statistical.VAR.P(ref1);\r\n    case 12:\r\n      return statistical.MEDIAN(ref1);\r\n    case 13:\r\n      return statistical.MODE.SNGL(ref1);\r\n    case 14:\r\n      return statistical.LARGE(ref1, ref2);\r\n    case 15:\r\n      return statistical.SMALL(ref1, ref2);\r\n    case 16:\r\n      return statistical.PERCENTILE.INC(ref1, ref2);\r\n    case 17:\r\n      return statistical.QUARTILE.INC(ref1, ref2);\r\n    case 18:\r\n      return statistical.PERCENTILE.EXC(ref1, ref2);\r\n    case 19:\r\n      return statistical.QUARTILE.EXC(ref1, ref2);\r\n  }\r\n};\r\n\r\nexports.ARABIC = function(text) {\r\n  // Credits: Rafa? Kukawski\r\n  if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {\r\n    return error.value;\r\n  }\r\n  var r = 0;\r\n  text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {\r\n    r += {\r\n      M: 1000,\r\n      CM: 900,\r\n      D: 500,\r\n      CD: 400,\r\n      C: 100,\r\n      XC: 90,\r\n      L: 50,\r\n      XL: 40,\r\n      X: 10,\r\n      IX: 9,\r\n      V: 5,\r\n      IV: 4,\r\n      I: 1\r\n    }[i];\r\n  });\r\n  return r;\r\n};\r\n\r\nexports.ASIN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = Math.asin(number);\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.ASINH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.log(number + Math.sqrt(number * number + 1));\r\n};\r\n\r\nexports.ATAN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.atan(number);\r\n};\r\n\r\nexports.ATAN2 = function(number_x, number_y) {\r\n  number_x = utils.parseNumber(number_x);\r\n  number_y = utils.parseNumber(number_y);\r\n  if (utils.anyIsError(number_x, number_y)) {\r\n    return error.value;\r\n  }\r\n  return Math.atan2(number_x, number_y);\r\n};\r\n\r\nexports.ATANH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var result = Math.log((1 + number) / (1 - number)) / 2;\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.BASE = function(number, radix, min_length) {\r\n  min_length = min_length || 0;\r\n\r\n  number = utils.parseNumber(number);\r\n  radix = utils.parseNumber(radix);\r\n  min_length = utils.parseNumber(min_length);\r\n  if (utils.anyIsError(number, radix, min_length)) {\r\n    return error.value;\r\n  }\r\n  min_length = (min_length === undefined) ? 0 : min_length;\r\n  var result = number.toString(radix);\r\n  return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;\r\n};\r\n\r\nexports.CEILING = function(number, significance, mode) {\r\n  significance = (significance === undefined) ? 1 : Math.abs(significance);\r\n  mode = mode || 0;\r\n\r\n  number = utils.parseNumber(number);\r\n  significance = utils.parseNumber(significance);\r\n  mode = utils.parseNumber(mode);\r\n  if (utils.anyIsError(number, significance, mode)) {\r\n    return error.value;\r\n  }\r\n  if (significance === 0) {\r\n    return 0;\r\n  }\r\n  var precision = -Math.floor(Math.log(significance) / Math.log(10));\r\n  if (number >= 0) {\r\n    return exports.ROUND(Math.ceil(number / significance) * significance, precision);\r\n  } else {\r\n    if (mode === 0) {\r\n      return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);\r\n    } else {\r\n      return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);\r\n    }\r\n  }\r\n};\r\n\r\nexports.CEILING.MATH = exports.CEILING;\r\n\r\nexports.CEILING.PRECISE = exports.CEILING;\r\n\r\nexports.COMBIN = function(number, number_chosen) {\r\n  number = utils.parseNumber(number);\r\n  number_chosen = utils.parseNumber(number_chosen);\r\n  if (utils.anyIsError(number, number_chosen)) {\r\n    return error.value;\r\n  }\r\n  return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));\r\n};\r\n\r\nexports.COMBINA = function(number, number_chosen) {\r\n  number = utils.parseNumber(number);\r\n  number_chosen = utils.parseNumber(number_chosen);\r\n  if (utils.anyIsError(number, number_chosen)) {\r\n    return error.value;\r\n  }\r\n  return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);\r\n};\r\n\r\nexports.COS = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.cos(number);\r\n};\r\n\r\nexports.COSH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return (Math.exp(number) + Math.exp(-number)) / 2;\r\n};\r\n\r\nexports.COT = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return 1 / Math.tan(number);\r\n};\r\n\r\nexports.COTH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var e2 = Math.exp(2 * number);\r\n  return (e2 + 1) / (e2 - 1);\r\n};\r\n\r\nexports.CSC = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return 1 / Math.sin(number);\r\n};\r\n\r\nexports.CSCH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return 2 / (Math.exp(number) - Math.exp(-number));\r\n};\r\n\r\nexports.DECIMAL = function(number, radix) {\r\n  if (arguments.length < 1) {\r\n    return error.value;\r\n  }\r\n\r\n  return parseInt(number, radix);\r\n};\r\n\r\nexports.DEGREES = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return number * 180 / Math.PI;\r\n};\r\n\r\nexports.EVEN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return exports.CEILING(number, -2, -1);\r\n};\r\n\r\nexports.EXP = function(number) {\r\n  if (arguments.length < 1) {\r\n    return error.na;\r\n  }\r\n  if (typeof number !== 'number' || arguments.length > 1) {\r\n    return error.error;\r\n  }\r\n\r\n  number = Math.exp(number);\r\n\r\n  return number;\r\n};\r\n\r\nvar MEMOIZED_FACT = [];\r\nexports.FACT = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var n = Math.floor(number);\r\n  if (n === 0 || n === 1) {\r\n    return 1;\r\n  } else if (MEMOIZED_FACT[n] > 0) {\r\n    return MEMOIZED_FACT[n];\r\n  } else {\r\n    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;\r\n    return MEMOIZED_FACT[n];\r\n  }\r\n};\r\n\r\nexports.FACTDOUBLE = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var n = Math.floor(number);\r\n  if (n <= 0) {\r\n    return 1;\r\n  } else {\r\n    return n * exports.FACTDOUBLE(n - 2);\r\n  }\r\n};\r\n\r\nexports.FLOOR = function(number, significance) {\r\n  number = utils.parseNumber(number);\r\n  significance = utils.parseNumber(significance);\r\n  if (utils.anyIsError(number, significance)) {\r\n    return error.value;\r\n  }\r\n  if (significance === 0) {\r\n    return 0;\r\n  }\r\n\r\n  if (!(number > 0 && significance > 0) && !(number < 0 && significance < 0)) {\r\n    return error.num;\r\n  }\r\n\r\n  significance = Math.abs(significance);\r\n  var precision = -Math.floor(Math.log(significance) / Math.log(10));\r\n  if (number >= 0) {\r\n    return exports.ROUND(Math.floor(number / significance) * significance, precision);\r\n  } else {\r\n    return -exports.ROUND(Math.ceil(Math.abs(number) / significance), precision);\r\n  }\r\n};\r\n\r\n//TODO: Verify\r\nexports.FLOOR.MATH = function(number, significance, mode) {\r\n  significance = (significance === undefined) ? 1 : significance;\r\n  mode = (mode === undefined) ? 0 : mode;\r\n\r\n  number = utils.parseNumber(number);\r\n  significance = utils.parseNumber(significance);\r\n  mode = utils.parseNumber(mode);\r\n  if (utils.anyIsError(number, significance, mode)) {\r\n    return error.value;\r\n  }\r\n  if (significance === 0) {\r\n    return 0;\r\n  }\r\n\r\n  significance = significance ? Math.abs(significance) : 1;\r\n  var precision = -Math.floor(Math.log(significance) / Math.log(10));\r\n  if (number >= 0) {\r\n    return exports.ROUND(Math.floor(number / significance) * significance, precision);\r\n  } else if (mode === 0 || mode === undefined) {\r\n    return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);\r\n  }\r\n  return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);\r\n};\r\n\r\n// Deprecated\r\nexports.FLOOR.PRECISE = exports.FLOOR.MATH;\r\n\r\n// adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript\r\nexports.GCD = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var n = range.length;\r\n  var r0 = range[0];\r\n  var x = r0 < 0 ? -r0 : r0;\r\n  for (var i = 1; i < n; i++) {\r\n    var ri = range[i];\r\n    var y = ri < 0 ? -ri : ri;\r\n    while (x && y) {\r\n      if (x > y) {\r\n        x %= y;\r\n      } else {\r\n        y %= x;\r\n      }\r\n    }\r\n    x += y;\r\n  }\r\n  return x;\r\n};\r\n\r\n\r\nexports.INT = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.floor(number);\r\n};\r\n\r\n//TODO: verify\r\nexports.ISO = {\r\n  CEILING: exports.CEILING\r\n};\r\n\r\nexports.LCM = function() {\r\n  // Credits: Jonas Raoni Soares Silva\r\n  var o = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (o instanceof Error) {\r\n    return o;\r\n  }\r\n  for (var i, j, n, d, r = 1;\r\n       (n = o.pop()) !== undefined;) {\r\n    while (n > 1) {\r\n      if (n % 2) {\r\n        for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {\r\n          //empty\r\n        }\r\n        d = (i <= j) ? i : n;\r\n      } else {\r\n        d = 2;\r\n      }\r\n      for (n /= d, r *= d, i = o.length; i;\r\n           (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {\r\n        //empty\r\n      }\r\n    }\r\n  }\r\n  return r;\r\n};\r\n\r\nexports.LN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.log(number);\r\n};\r\n\r\nexports.LN10 = function() {\r\n  return Math.log(10);\r\n};\r\n\r\nexports.LN2 = function() {\r\n  return Math.log(2);\r\n};\r\n\r\nexports.LOG10E = function() {\r\n  return Math.LOG10E;\r\n};\r\n\r\nexports.LOG2E = function() {\r\n  return Math.LOG2E;\r\n};\r\n\r\nexports.LOG = function(number, base) {\r\n  number = utils.parseNumber(number);\r\n  base = utils.parseNumber(base);\r\n  if (utils.anyIsError(number, base)) {\r\n    return error.value;\r\n  }\r\n  base = (base === undefined) ? 10 : base;\r\n  return Math.log(number) / Math.log(base);\r\n};\r\n\r\nexports.LOG10 = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.log(number) / Math.log(10);\r\n};\r\n\r\nexports.MOD = function(dividend, divisor) {\r\n  dividend = utils.parseNumber(dividend);\r\n  divisor = utils.parseNumber(divisor);\r\n  if (utils.anyIsError(dividend, divisor)) {\r\n    return error.value;\r\n  }\r\n  if (divisor === 0) {\r\n    return error.div0;\r\n  }\r\n  var modulus = Math.abs(dividend % divisor);\r\n  return (divisor > 0) ? modulus : -modulus;\r\n};\r\n\r\nexports.MROUND = function(number, multiple) {\r\n  number = utils.parseNumber(number);\r\n  multiple = utils.parseNumber(multiple);\r\n  if (utils.anyIsError(number, multiple)) {\r\n    return error.value;\r\n  }\r\n  if (number * multiple < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  return Math.round(number / multiple) * multiple;\r\n};\r\n\r\nexports.MULTINOMIAL = function() {\r\n  var args = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (args instanceof Error) {\r\n    return args;\r\n  }\r\n  var sum = 0;\r\n  var divisor = 1;\r\n  for (var i = 0; i < args.length; i++) {\r\n    sum += args[i];\r\n    divisor *= exports.FACT(args[i]);\r\n  }\r\n  return exports.FACT(sum) / divisor;\r\n};\r\n\r\nexports.ODD = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var temp = Math.ceil(Math.abs(number));\r\n  temp = (temp & 1) ? temp : temp + 1;\r\n  return (number > 0) ? temp : -temp;\r\n};\r\n\r\nexports.PI = function() {\r\n  return Math.PI;\r\n};\r\n\r\nexports.E = function() {\r\n  return Math.E;\r\n};\r\n\r\nexports.POWER = function(number, power) {\r\n  number = utils.parseNumber(number);\r\n  power = utils.parseNumber(power);\r\n  if (utils.anyIsError(number, power)) {\r\n    return error.value;\r\n  }\r\n  var result = Math.pow(number, power);\r\n  if (isNaN(result)) {\r\n    return error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.PRODUCT = function() {\r\n  var args = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (args instanceof Error) {\r\n    return args;\r\n  }\r\n  var result = 1;\r\n  for (var i = 0; i < args.length; i++) {\r\n    result *= args[i];\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.QUOTIENT = function(numerator, denominator) {\r\n  numerator = utils.parseNumber(numerator);\r\n  denominator = utils.parseNumber(denominator);\r\n  if (utils.anyIsError(numerator, denominator)) {\r\n    return error.value;\r\n  }\r\n  return parseInt(numerator / denominator, 10);\r\n};\r\n\r\nexports.RADIANS = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return number * Math.PI / 180;\r\n};\r\n\r\nexports.RAND = function() {\r\n  return Math.random();\r\n};\r\n\r\nexports.RANDBETWEEN = function(bottom, top) {\r\n  bottom = utils.parseNumber(bottom);\r\n  top = utils.parseNumber(top);\r\n  if (utils.anyIsError(bottom, top)) {\r\n    return error.value;\r\n  }\r\n  // Creative Commons Attribution 3.0 License\r\n  // Copyright (c) 2012 eqcode\r\n  return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;\r\n};\r\n\r\n// TODO\r\nexports.ROMAN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  // The MIT License\r\n  // Copyright (c) 2008 Steven Levithan\r\n  var digits = String(number).split('');\r\n  var key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];\r\n  var roman = '';\r\n  var i = 3;\r\n  while (i--) {\r\n    roman = (key[+digits.pop() + (i * 10)] || '') + roman;\r\n  }\r\n  return new Array(+digits.join('') + 1).join('M') + roman;\r\n};\r\n\r\nexports.ROUND = function(number, digits) {\r\n  number = utils.parseNumber(number);\r\n  digits = utils.parseNumber(digits);\r\n  if (utils.anyIsError(number, digits)) {\r\n    return error.value;\r\n  }\r\n  return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);\r\n};\r\n\r\nexports.ROUNDDOWN = function(number, digits) {\r\n  number = utils.parseNumber(number);\r\n  digits = utils.parseNumber(digits);\r\n  if (utils.anyIsError(number, digits)) {\r\n    return error.value;\r\n  }\r\n  var sign = (number > 0) ? 1 : -1;\r\n  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);\r\n};\r\n\r\nexports.ROUNDUP = function(number, digits) {\r\n  number = utils.parseNumber(number);\r\n  digits = utils.parseNumber(digits);\r\n  if (utils.anyIsError(number, digits)) {\r\n    return error.value;\r\n  }\r\n  var sign = (number > 0) ? 1 : -1;\r\n  return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);\r\n};\r\n\r\nexports.SEC = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return 1 / Math.cos(number);\r\n};\r\n\r\nexports.SECH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return 2 / (Math.exp(number) + Math.exp(-number));\r\n};\r\n\r\nexports.SERIESSUM = function(x, n, m, coefficients) {\r\n  x = utils.parseNumber(x);\r\n  n = utils.parseNumber(n);\r\n  m = utils.parseNumber(m);\r\n  coefficients = utils.parseNumberArray(coefficients);\r\n  if (utils.anyIsError(x, n, m, coefficients)) {\r\n    return error.value;\r\n  }\r\n  var result = coefficients[0] * Math.pow(x, n);\r\n  for (var i = 1; i < coefficients.length; i++) {\r\n    result += coefficients[i] * Math.pow(x, n + i * m);\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.SIGN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  if (number < 0) {\r\n    return -1;\r\n  } else if (number === 0) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n};\r\n\r\nexports.SIN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.sin(number);\r\n};\r\n\r\nexports.SINH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return (Math.exp(number) - Math.exp(-number)) / 2;\r\n};\r\n\r\nexports.SQRT = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  if (number < 0) {\r\n    return error.num;\r\n  }\r\n  return Math.sqrt(number);\r\n};\r\n\r\nexports.SQRTPI = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.sqrt(number * Math.PI);\r\n};\r\n\r\nexports.SQRT1_2 = function() {\r\n  return 1 / Math.sqrt(2);\r\n};\r\n\r\nexports.SQRT2 = function() {\r\n  return Math.sqrt(2);\r\n};\r\n\r\nexports.SUBTOTAL = function(function_code, ref1) {\r\n  function_code = utils.parseNumber(function_code);\r\n  if (function_code instanceof Error) {\r\n    return function_code;\r\n  }\r\n  switch (function_code) {\r\n    case 1:\r\n      return statistical.AVERAGE(ref1);\r\n    case 2:\r\n      return statistical.COUNT(ref1);\r\n    case 3:\r\n      return statistical.COUNTA(ref1);\r\n    case 4:\r\n      return statistical.MAX(ref1);\r\n    case 5:\r\n      return statistical.MIN(ref1);\r\n    case 6:\r\n      return exports.PRODUCT(ref1);\r\n    case 7:\r\n      return statistical.STDEV.S(ref1);\r\n    case 8:\r\n      return statistical.STDEV.P(ref1);\r\n    case 9:\r\n      return exports.SUM(ref1);\r\n    case 10:\r\n      return statistical.VAR.S(ref1);\r\n    case 11:\r\n      return statistical.VAR.P(ref1);\r\n    // no hidden values for us\r\n    case 101:\r\n      return statistical.AVERAGE(ref1);\r\n    case 102:\r\n      return statistical.COUNT(ref1);\r\n    case 103:\r\n      return statistical.COUNTA(ref1);\r\n    case 104:\r\n      return statistical.MAX(ref1);\r\n    case 105:\r\n      return statistical.MIN(ref1);\r\n    case 106:\r\n      return exports.PRODUCT(ref1);\r\n    case 107:\r\n      return statistical.STDEV.S(ref1);\r\n    case 108:\r\n      return statistical.STDEV.P(ref1);\r\n    case 109:\r\n      return exports.SUM(ref1);\r\n    case 110:\r\n      return statistical.VAR.S(ref1);\r\n    case 111:\r\n      return statistical.VAR.P(ref1);\r\n\r\n  }\r\n};\r\n\r\nexports.ADD = function (num1, num2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  num1 = utils.parseNumber(num1);\r\n  num2 = utils.parseNumber(num2);\r\n  if (utils.anyIsError(num1, num2)) {\r\n    return error.value;\r\n  }\r\n\r\n  return num1 + num2;\r\n};\r\n\r\nexports.MINUS = function (num1, num2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  num1 = utils.parseNumber(num1);\r\n  num2 = utils.parseNumber(num2);\r\n  if (utils.anyIsError(num1, num2)) {\r\n    return error.value;\r\n  }\r\n\r\n  return num1 - num2;\r\n};\r\n\r\nexports.DIVIDE = function (dividend, divisor) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  dividend = utils.parseNumber(dividend);\r\n  divisor = utils.parseNumber(divisor);\r\n  if (utils.anyIsError(dividend, divisor)) {\r\n    return error.value;\r\n  }\r\n\r\n  if (divisor === 0) {\r\n    return error.div0;\r\n  }\r\n\r\n  return dividend / divisor;\r\n};\r\n\r\nexports.MULTIPLY = function (factor1, factor2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  factor1 = utils.parseNumber(factor1);\r\n  factor2 = utils.parseNumber(factor2);\r\n  if (utils.anyIsError(factor1, factor2)) {\r\n    return error.value;\r\n  }\r\n\r\n  return factor1 * factor2;\r\n};\r\n\r\nexports.GTE = function (num1, num2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  num1 = utils.parseNumber(num1);\r\n  num2 = utils.parseNumber(num2);\r\n  if (utils.anyIsError(num1, num2)) {\r\n    return error.error;\r\n  }\r\n\r\n  return num1 >= num2;\r\n};\r\n\r\nexports.LT = function (num1, num2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  num1 = utils.parseNumber(num1);\r\n  num2 = utils.parseNumber(num2);\r\n  if (utils.anyIsError(num1, num2)) {\r\n    return error.error;\r\n  }\r\n\r\n  return num1 < num2;\r\n};\r\n\r\n\r\nexports.LTE = function (num1, num2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  num1 = utils.parseNumber(num1);\r\n  num2 = utils.parseNumber(num2);\r\n  if (utils.anyIsError(num1, num2)) {\r\n    return error.error;\r\n  }\r\n\r\n  return num1 <= num2;\r\n};\r\n\r\nexports.EQ = function (value1, value2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  return value1 === value2;\r\n};\r\n\r\nexports.NE = function (value1, value2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  return value1 !== value2;\r\n};\r\n\r\nexports.POW = function (base, exponent) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  base = utils.parseNumber(base);\r\n  exponent = utils.parseNumber(exponent);\r\n  if (utils.anyIsError(base, exponent)) {\r\n    return error.error;\r\n  }\r\n\r\n  return exports.POWER(base, exponent);\r\n};\r\n\r\nexports.SUM = function() {\r\n  var result = 0;\r\n\r\n  utils.arrayEach(utils.argsToArray(arguments), function(value) {\r\n    if (typeof value === 'number') {\r\n      result += value;\r\n\r\n    } else if (typeof value === 'string') {\r\n      var parsed = parseFloat(value);\r\n\r\n      !isNaN(parsed) && (result += parsed);\r\n\r\n    } else if (Array.isArray(value)) {\r\n      result += exports.SUM.apply(null, value);\r\n    }\r\n  });\r\n\r\n  return result;\r\n};\r\n\r\nexports.SUMIF = function(range, criteria, sumRange) {\r\n  range = utils.flatten(range);\r\n  if (sumRange !== undefined) {\r\n    sumRange = utils.flatten(sumRange);\r\n  }\r\n  else{\r\n    sumRange = range;\r\n  }\r\n  var result = 0;\r\n\r\n  if (criteria.includes('>') || criteria.includes('<') || criteria.includes('=')) {\r\n    criteria = criteria.replace(/=/g, '==').replace(/<>/g, '!=');\r\n    for (var i = 0; i < range.length; i++) {\r\n      result += (eval('\"' + range[i] + '\"' + criteria)) ? sumRange[i] : 0; // jshint ignore:line\r\n    }\r\n  }\r\n  else {\r\n    // check if the criteria is same as range[i]\r\n    for (var i = 0; i < range.length; i++) {\r\n      result += ((\"\" + range[i]).toLowerCase() === (criteria + \"\").toLowerCase()) ? sumRange[i] : 0; // jshint ignore:line\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.SUMIFS = function() {\r\n  var args = utils.argsToArray(arguments);\r\n  var range = utils.parseNumberArray(utils.flatten(args.shift()));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var criteria = args;\r\n\r\n  var n_range_elements = range.length;\r\n  var n_criterias = criteria.length;\r\n\r\n  var result = 0;\r\n  for (var i = 0; i < n_range_elements; i++) {\r\n    var el = range[i];\r\n    var condition = '';\r\n    for (var c = 0; c < n_criterias; c++) {\r\n      condition += el + criteria[c];\r\n      if (c !== n_criterias - 1) {\r\n        condition += '&&';\r\n      }\r\n    }\r\n    if (eval(condition)) { // jshint ignore:line\r\n      result += el;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.SUMPRODUCT = function() {\r\n  if (!arguments || arguments.length === 0) {\r\n    return error.value;\r\n  }\r\n  var arrays = arguments.length + 1;\r\n  var result = 0;\r\n  var product;\r\n  var k;\r\n  var _i;\r\n  var _ij;\r\n  for (var i = 0; i < arguments[0].length; i++) {\r\n    if (!(arguments[0][i] instanceof Array)) {\r\n      product = 1;\r\n      for (k = 1; k < arrays; k++) {\r\n        _i = utils.parseNumber(arguments[k - 1][i]);\r\n        if (_i instanceof Error) {\r\n          return _i;\r\n        }\r\n        product *= _i;\r\n      }\r\n      result += product;\r\n    } else {\r\n      for (var j = 0; j < arguments[0][i].length; j++) {\r\n        product = 1;\r\n        for (k = 1; k < arrays; k++) {\r\n          _ij = utils.parseNumber(arguments[k - 1][i][j]);\r\n          if (_ij instanceof Error) {\r\n            return _ij;\r\n          }\r\n          product *= _ij;\r\n        }\r\n        result += product;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.SUMSQ = function() {\r\n  var numbers = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (numbers instanceof Error) {\r\n    return numbers;\r\n  }\r\n  var result = 0;\r\n  var length = numbers.length;\r\n  for (var i = 0; i < length; i++) {\r\n    result += (information.ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.SUMX2MY2 = function(array_x, array_y) {\r\n  array_x = utils.parseNumberArray(utils.flatten(array_x));\r\n  array_y = utils.parseNumberArray(utils.flatten(array_y));\r\n  if (utils.anyIsError(array_x, array_y)) {\r\n    return error.value;\r\n  }\r\n  var result = 0;\r\n  for (var i = 0; i < array_x.length; i++) {\r\n    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.SUMX2PY2 = function(array_x, array_y) {\r\n  array_x = utils.parseNumberArray(utils.flatten(array_x));\r\n  array_y = utils.parseNumberArray(utils.flatten(array_y));\r\n  if (utils.anyIsError(array_x, array_y)) {\r\n    return error.value;\r\n  }\r\n  var result = 0;\r\n  array_x = utils.parseNumberArray(utils.flatten(array_x));\r\n  array_y = utils.parseNumberArray(utils.flatten(array_y));\r\n  for (var i = 0; i < array_x.length; i++) {\r\n    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.SUMXMY2 = function(array_x, array_y) {\r\n  array_x = utils.parseNumberArray(utils.flatten(array_x));\r\n  array_y = utils.parseNumberArray(utils.flatten(array_y));\r\n  if (utils.anyIsError(array_x, array_y)) {\r\n    return error.value;\r\n  }\r\n  var result = 0;\r\n  array_x = utils.flatten(array_x);\r\n  array_y = utils.flatten(array_y);\r\n  for (var i = 0; i < array_x.length; i++) {\r\n    result += Math.pow(array_x[i] - array_y[i], 2);\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.TAN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return Math.tan(number);\r\n};\r\n\r\nexports.TANH = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  var e2 = Math.exp(2 * number);\r\n  return (e2 - 1) / (e2 + 1);\r\n};\r\n\r\nexports.TRUNC = function(number, digits) {\r\n  digits = (digits === undefined) ? 0 : digits;\r\n  number = utils.parseNumber(number);\r\n  digits = utils.parseNumber(digits);\r\n  if (utils.anyIsError(number, digits)) {\r\n    return error.value;\r\n  }\r\n  var sign = (number > 0) ? 1 : -1;\r\n  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/math-trig.js\n// module id = 16\n// module chunks = 0","var error = require('./error');\r\n\r\nexports.flattenShallow = function(array) {\r\n  if (!array || !array.reduce) {\r\n    return array;\r\n  }\r\n\r\n  return array.reduce(function(a, b) {\r\n    var aIsArray = Array.isArray(a);\r\n    var bIsArray = Array.isArray(b);\r\n\r\n    if (aIsArray && bIsArray ) {\r\n      return a.concat(b);\r\n    }\r\n    if (aIsArray) {\r\n      a.push(b);\r\n\r\n      return a;\r\n    }\r\n    if (bIsArray) {\r\n      return [a].concat(b);\r\n    }\r\n\r\n    return [a, b];\r\n  });\r\n};\r\n\r\nexports.isFlat = function(array) {\r\n  if (!array) {\r\n    return false;\r\n  }\r\n\r\n  for (var i = 0; i < array.length; ++i) {\r\n    if (Array.isArray(array[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.flatten = function() {\r\n  var result = exports.argsToArray.apply(null, arguments);\r\n\r\n  while (!exports.isFlat(result)) {\r\n    result = exports.flattenShallow(result);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.argsToArray = function(args) {\r\n  var result = [];\r\n\r\n  exports.arrayEach(args, function(value) {\r\n    result.push(value);\r\n  });\r\n\r\n  return result;\r\n};\r\n\r\nexports.numbers = function() {\r\n  var possibleNumbers = this.flatten.apply(null, arguments);\r\n  return possibleNumbers.filter(function(el) {\r\n    return typeof el === 'number';\r\n  });\r\n};\r\n\r\nexports.cleanFloat = function(number) {\r\n  var power = 1e14;\r\n  return Math.round(number * power) / power;\r\n};\r\n\r\nexports.parseBool = function(bool) {\r\n  if (typeof bool === 'boolean') {\r\n    return bool;\r\n  }\r\n\r\n  if (bool instanceof Error) {\r\n    return bool;\r\n  }\r\n\r\n  if (typeof bool === 'number') {\r\n    return bool !== 0;\r\n  }\r\n\r\n  if (typeof bool === 'string') {\r\n    var up = bool.toUpperCase();\r\n    if (up === 'TRUE') {\r\n      return true;\r\n    }\r\n\r\n    if (up === 'FALSE') {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (bool instanceof Date && !isNaN(bool)) {\r\n    return true;\r\n  }\r\n\r\n  return error.value;\r\n};\r\n\r\nexports.parseNumber = function(string) {\r\n  if (string === undefined || string === '') {\r\n    return error.value;\r\n  }\r\n  if (!isNaN(string)) {\r\n    return parseFloat(string);\r\n  }\r\n\r\n  return error.value;\r\n};\r\n\r\nexports.parseNumberArray = function(arr) {\r\n  var len;\r\n\r\n  if (!arr || (len = arr.length) === 0) {\r\n    return error.value;\r\n  }\r\n\r\n  var parsed;\r\n\r\n  while (len--) {\r\n    parsed = exports.parseNumber(arr[len]);\r\n    if (parsed === error.value) {\r\n      return parsed;\r\n    }\r\n    arr[len] = parsed;\r\n  }\r\n\r\n  return arr;\r\n};\r\n\r\nexports.parseMatrix = function(matrix) {\r\n  var n;\r\n\r\n  if (!matrix || (n = matrix.length) === 0) {\r\n    return error.value;\r\n  }\r\n  var pnarr;\r\n\r\n  for (var i = 0; i < matrix.length; i++) {\r\n    pnarr = exports.parseNumberArray(matrix[i]);\r\n    matrix[i] = pnarr;\r\n\r\n    if (pnarr instanceof Error) {\r\n      return pnarr;\r\n    }\r\n  }\r\n\r\n  return matrix;\r\n};\r\n\r\nvar d1900 = new Date(Date.UTC(1900, 0, 1));\r\nexports.parseDate = function(date) {\r\n  if (!isNaN(date)) {\r\n    if (date instanceof Date) {\r\n      return new Date(date);\r\n    }\r\n    var d = parseInt(date, 10);\r\n    if (d < 0) {\r\n      return error.num;\r\n    }\r\n    if (d <= 60) {\r\n      return new Date(d1900.getTime() + (d - 1) * 86400000);\r\n    }\r\n    return new Date(d1900.getTime() + (d - 2) * 86400000);\r\n  }\r\n  if (typeof date === 'string') {\r\n    date = new Date(date);\r\n    if (!isNaN(date)) {\r\n      return date;\r\n    }\r\n  }\r\n  return error.value;\r\n};\r\n\r\nexports.parseDateArray = function(arr) {\r\n  var len = arr.length;\r\n  var parsed;\r\n  while (len--) {\r\n    parsed = this.parseDate(arr[len]);\r\n    if (parsed === error.value) {\r\n      return parsed;\r\n    }\r\n    arr[len] = parsed;\r\n  }\r\n  return arr;\r\n};\r\n\r\nexports.anyIsError = function() {\r\n  var n = arguments.length;\r\n  while (n--) {\r\n    if (arguments[n] instanceof Error) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nexports.arrayValuesToNumbers = function(arr) {\r\n  var n = arr.length;\r\n  var el;\r\n  while (n--) {\r\n    el = arr[n];\r\n    if (typeof el === 'number') {\r\n      continue;\r\n    }\r\n    if (el === true) {\r\n      arr[n] = 1;\r\n      continue;\r\n    }\r\n    if (el === false) {\r\n      arr[n] = 0;\r\n      continue;\r\n    }\r\n    if (typeof el === 'string') {\r\n      var number = this.parseNumber(el);\r\n      if (number instanceof Error) {\r\n        arr[n] = 0;\r\n      } else {\r\n        arr[n] = number;\r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n};\r\n\r\nexports.rest = function(array, idx) {\r\n  idx = idx || 1;\r\n  if (!array || typeof array.slice !== 'function') {\r\n    return array;\r\n  }\r\n  return array.slice(idx);\r\n};\r\n\r\nexports.initial = function(array, idx) {\r\n  idx = idx || 1;\r\n  if (!array || typeof array.slice !== 'function') {\r\n    return array;\r\n  }\r\n  return array.slice(0, array.length - idx);\r\n};\r\n\r\nexports.arrayEach = function(array, iteratee) {\r\n  var index = -1, length = array.length;\r\n\r\n  while (++index < length) {\r\n    if (iteratee(array[index], index, array) === false) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return array;\r\n};\r\n\r\nexports.transpose = function(matrix) {\r\n  if(!matrix) { \r\n    return error.value;\r\n  }\r\n\r\n  return matrix[0].map(function(col, i) { \r\n    return matrix.map(function(row) { \r\n      return row[i];\r\n    });\r\n  });\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/utils.js\n// module id = 17\n// module chunks = 0","exports.nil = new Error('#NULL!');\r\nexports.div0 = new Error('#DIV/0!');\r\nexports.value = new Error('#VALUE!');\r\nexports.ref = new Error('#REF!');\r\nexports.name = new Error('#NAME?');\r\nexports.num = new Error('#NUM!');\r\nexports.na = new Error('#N/A');\r\nexports.error = new Error('#ERROR!');\r\nexports.data = new Error('#GETTING_DATA');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/error.js\n// module id = 18\n// module chunks = 0","var mathTrig = require('./math-trig');\r\nvar text = require('./text');\r\nvar jStat = require('jStat').jStat;\r\nvar utils = require('./utils');\r\nvar error = require('./error');\r\nvar misc = require('./miscellaneous');\r\n\r\nvar SQRT2PI = 2.5066282746310002;\r\n\r\nexports.AVEDEV = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;\r\n};\r\n\r\nexports.AVERAGE = function() {\r\n  var range = utils.numbers(utils.flatten(arguments));\r\n  var n = range.length;\r\n  var sum = 0;\r\n  var count = 0;\r\n  var result;\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    sum += range[i];\r\n    count += 1;\r\n  }\r\n  result = sum / count;\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.AVERAGEA = function() {\r\n  var range = utils.flatten(arguments);\r\n  var n = range.length;\r\n  var sum = 0;\r\n  var count = 0;\r\n  var result;\r\n  for (var i = 0; i < n; i++) {\r\n    var el = range[i];\r\n    if (typeof el === 'number') {\r\n      sum += el;\r\n    }\r\n    if (el === true) {\r\n      sum++;\r\n    }\r\n    if (el !== null) {\r\n      count++;\r\n    }\r\n  }\r\n  result = sum / count;\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.AVERAGEIF = function(range, criteria, average_range) {\r\n  if (arguments.length <= 1) {\r\n    return error.na;\r\n  }\r\n  average_range = average_range || range;\r\n  range = utils.flatten(range);\r\n  average_range = utils.parseNumberArray(utils.flatten(average_range));\r\n  if (average_range instanceof Error) {\r\n    return average_range;\r\n  }\r\n  var average_count = 0;\r\n  var result = 0;\r\n  for (var i = 0; i < range.length; i++) {\r\n    if (eval(range[i] + criteria)) { // jshint ignore:line\r\n      result += average_range[i];\r\n      average_count++;\r\n    }\r\n  }\r\n  return result / average_count;\r\n};\r\n\r\nexports.AVERAGEIFS = function() {\r\n  // Does not work with multi dimensional ranges yet!\r\n  //http://office.microsoft.com/en-001/excel-help/averageifs-function-HA010047493.aspx\r\n  var args = utils.argsToArray(arguments);\r\n  var criteria = (args.length - 1) / 2;\r\n  var range = utils.flatten(args[0]);\r\n  var count = 0;\r\n  var result = 0;\r\n  for (var i = 0; i < range.length; i++) {\r\n    var condition = '';\r\n    for (var j = 0; j < criteria; j++) {\r\n      condition += args[2 * j + 1][i] + args[2 * j + 2];\r\n      if (j !== criteria - 1) {\r\n        condition += '&&';\r\n      }\r\n    }\r\n    if (eval(condition)) { // jshint ignore:line\r\n      result += range[i];\r\n      count++;\r\n    }\r\n  }\r\n\r\n  var average = result / count;\r\n  if (isNaN(average)) {\r\n    return 0;\r\n  } else {\r\n    return average;\r\n  }\r\n};\r\n\r\nexports.BETA = {};\r\n\r\nexports.BETA.DIST = function(x, alpha, beta, cumulative, A, B) {\r\n  if (arguments.length < 4) {\r\n    return error.value;\r\n  }\r\n\r\n  A = (A === undefined) ? 0 : A;\r\n  B = (B === undefined) ? 1 : B;\r\n\r\n  x = utils.parseNumber(x);\r\n  alpha = utils.parseNumber(alpha);\r\n  beta = utils.parseNumber(beta);\r\n  A = utils.parseNumber(A);\r\n  B = utils.parseNumber(B);\r\n  if (utils.anyIsError(x, alpha, beta, A, B)) {\r\n    return error.value;\r\n  }\r\n\r\n  x = (x - A) / (B - A);\r\n  return (cumulative) ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta);\r\n};\r\n\r\nexports.BETA.INV = function(probability, alpha, beta, A, B) {\r\n  A = (A === undefined) ? 0 : A;\r\n  B = (B === undefined) ? 1 : B;\r\n\r\n  probability = utils.parseNumber(probability);\r\n  alpha = utils.parseNumber(alpha);\r\n  beta = utils.parseNumber(beta);\r\n  A = utils.parseNumber(A);\r\n  B = utils.parseNumber(B);\r\n  if (utils.anyIsError(probability, alpha, beta, A, B)) {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.beta.inv(probability, alpha, beta) * (B - A) + A;\r\n};\r\n\r\nexports.BINOM = {};\r\n\r\nexports.BINOM.DIST = function(successes, trials, probability, cumulative) {\r\n  successes = utils.parseNumber(successes);\r\n  trials = utils.parseNumber(trials);\r\n  probability = utils.parseNumber(probability);\r\n  cumulative = utils.parseNumber(cumulative);\r\n  if (utils.anyIsError(successes, trials, probability, cumulative)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);\r\n};\r\n\r\nexports.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {\r\n  successes2 = (successes2 === undefined) ? successes : successes2;\r\n\r\n  trials = utils.parseNumber(trials);\r\n  probability = utils.parseNumber(probability);\r\n  successes = utils.parseNumber(successes);\r\n  successes2 = utils.parseNumber(successes2);\r\n  if (utils.anyIsError(trials, probability, successes, successes2)) {\r\n    return error.value;\r\n  }\r\n\r\n  var result = 0;\r\n  for (var i = successes; i <= successes2; i++) {\r\n    result += mathTrig.COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.BINOM.INV = function(trials, probability, alpha) {\r\n  trials = utils.parseNumber(trials);\r\n  probability = utils.parseNumber(probability);\r\n  alpha = utils.parseNumber(alpha);\r\n  if (utils.anyIsError(trials, probability, alpha)) {\r\n    return error.value;\r\n  }\r\n\r\n  var x = 0;\r\n  while (x <= trials) {\r\n    if (jStat.binomial.cdf(x, trials, probability) >= alpha) {\r\n      return x;\r\n    }\r\n    x++;\r\n  }\r\n};\r\n\r\nexports.CHISQ = {};\r\n\r\nexports.CHISQ.DIST = function(x, k, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  k = utils.parseNumber(k);\r\n  if (utils.anyIsError(x, k)) {\r\n    return error.value;\r\n  }\r\n\r\n  return (cumulative) ? jStat.chisquare.cdf(x, k) : jStat.chisquare.pdf(x, k);\r\n};\r\n\r\nexports.CHISQ.DIST.RT = function(x, k) {\r\n  if (!x | !k) {\r\n    return error.na;\r\n  }\r\n\r\n  if (x < 1 || k > Math.pow(10, 10)) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof x !== 'number') || (typeof k !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return 1 -  jStat.chisquare.cdf(x, k);\r\n};\r\n\r\nexports.CHISQ.INV = function(probability, k) {\r\n  probability = utils.parseNumber(probability);\r\n  k = utils.parseNumber(k);\r\n  if (utils.anyIsError(probability, k)) {\r\n    return error.value;\r\n  }\r\n  return jStat.chisquare.inv(probability, k);\r\n};\r\n\r\nexports.CHISQ.INV.RT = function(p, k) {\r\n  if (!p | !k) {\r\n    return error.na;\r\n  }\r\n\r\n  if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof p !== 'number') || (typeof k !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.chisquare.inv(1.0 - p, k);\r\n};\r\n\r\nexports.CHISQ.TEST = function(observed, expected) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  if ((!(observed instanceof Array)) || (!(expected instanceof Array))) {\r\n    return error.value;\r\n  }\r\n\r\n  if (observed.length !== expected.length) {\r\n    return error.value;\r\n  }\r\n\r\n  if (observed[0] && expected[0] &&\r\n    observed[0].length !== expected[0].length) {\r\n    return error.value;\r\n  }\r\n\r\n  var row = observed.length;\r\n  var tmp, i, j;\r\n\r\n  // Convert single-dimension array into two-dimension array\r\n  for (i = 0; i < row; i ++) {\r\n    if (!(observed[i] instanceof Array)) {\r\n      tmp = observed[i];\r\n      observed[i] = [];\r\n      observed[i].push(tmp);\r\n    }\r\n    if (!(expected[i] instanceof Array)) {\r\n      tmp = expected[i];\r\n      expected[i] = [];\r\n      expected[i].push(tmp);\r\n    }\r\n  }\r\n\r\n  var col = observed[0].length;\r\n  var dof = (col === 1) ? row-1 : (row-1)*(col-1);\r\n  var xsqr = 0;\r\n  var Pi =Math.PI;\r\n\r\n  for (i = 0; i < row; i ++) {\r\n    for (j = 0; j < col; j ++) {\r\n      xsqr += Math.pow((observed[i][j] - expected[i][j]), 2) / expected[i][j];\r\n    }\r\n  }\r\n\r\n  // Get independency by X square and its degree of freedom\r\n  function ChiSq(xsqr, dof) {\r\n    var p = Math.exp(-0.5 * xsqr);\r\n    if((dof%2) === 1) {\r\n      p = p * Math.sqrt(2 * xsqr/Pi);\r\n    }\r\n    var k = dof;\r\n    while(k >= 2) {\r\n      p = p * xsqr/k;\r\n      k = k - 2;\r\n    }\r\n    var t = p;\r\n    var a = dof;\r\n    while (t > 0.0000000001*p) {\r\n      a = a + 2;\r\n      t = t * xsqr/a;\r\n      p = p + t;\r\n    }\r\n    return 1-p;\r\n  }\r\n\r\n  return Math.round(ChiSq(xsqr, dof) * 1000000) / 1000000;\r\n};\r\n\r\nexports.COLUMN = function(matrix, index) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  if (index < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  if (!(matrix instanceof Array) || (typeof index !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  if (matrix.length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return jStat.col(matrix, index);\r\n};\r\n\r\nexports.COLUMNS = function(matrix) {\r\n  if (arguments.length !== 1) {\r\n    return error.na;\r\n  }\r\n\r\n  if (!(matrix instanceof Array)) {\r\n    return error.value;\r\n  }\r\n\r\n  if (matrix.length === 0) {\r\n    return 0;\r\n  }\r\n\r\n  return jStat.cols(matrix);\r\n};\r\n\r\nexports.CONFIDENCE = {};\r\n\r\nexports.CONFIDENCE.NORM = function(alpha, sd, n) {\r\n  alpha = utils.parseNumber(alpha);\r\n  sd = utils.parseNumber(sd);\r\n  n = utils.parseNumber(n);\r\n  if (utils.anyIsError(alpha, sd, n)) {\r\n    return error.value;\r\n  }\r\n  return jStat.normalci(1, alpha, sd, n)[1] - 1;\r\n};\r\n\r\nexports.CONFIDENCE.T = function(alpha, sd, n) {\r\n  alpha = utils.parseNumber(alpha);\r\n  sd = utils.parseNumber(sd);\r\n  n = utils.parseNumber(n);\r\n  if (utils.anyIsError(alpha, sd, n)) {\r\n    return error.value;\r\n  }\r\n  return jStat.tci(1, alpha, sd, n)[1] - 1;\r\n};\r\n\r\nexports.CORREL = function(array1, array2) {\r\n  array1 = utils.parseNumberArray(utils.flatten(array1));\r\n  array2 = utils.parseNumberArray(utils.flatten(array2));\r\n  if (utils.anyIsError(array1, array2)) {\r\n    return error.value;\r\n  }\r\n  return jStat.corrcoeff(array1, array2);\r\n};\r\n\r\nexports.COUNT = function() {\r\n  return utils.numbers(utils.flatten(arguments)).length;\r\n};\r\n\r\nexports.COUNTA = function() {\r\n  var range = utils.flatten(arguments);\r\n  return range.length - exports.COUNTBLANK(range);\r\n};\r\n\r\nexports.COUNTIN = function (range, value) {\r\n  var result = 0;\r\n\r\n  range = utils.flatten(range);\r\n\r\n  for (var i = 0; i < range.length; i++) {\r\n    if (range[i] === value) {\r\n      result++;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\nexports.COUNTBLANK = function() {\r\n  var range = utils.flatten(arguments);\r\n  var blanks = 0;\r\n  var element;\r\n  for (var i = 0; i < range.length; i++) {\r\n    element = range[i];\r\n    if (element === null || element === '') {\r\n      blanks++;\r\n    }\r\n  }\r\n  return blanks;\r\n};\r\n\r\nexports.COUNTIF = function(range, criteria) {\r\n  range = utils.flatten(range);\r\n  if (!/[<>=!]/.test(criteria)) {\r\n    criteria = '==\"' + criteria + '\"';\r\n  }\r\n  var matches = 0;\r\n  for (var i = 0; i < range.length; i++) {\r\n    if (typeof range[i] !== 'string') {\r\n      if (eval(range[i] + criteria)) { // jshint ignore:line\r\n        matches++;\r\n      }\r\n    } else {\r\n      if (eval('\"' + range[i] + '\"' + criteria)) { // jshint ignore:line\r\n        matches++;\r\n      }\r\n    }\r\n  }\r\n  return matches;\r\n};\r\n\r\nexports.COUNTIFS = function() {\r\n  var args = utils.argsToArray(arguments);\r\n  var results = new Array(utils.flatten(args[0]).length);\r\n  for (var i = 0; i < results.length; i++) {\r\n    results[i] = true;\r\n  }\r\n  for (i = 0; i < args.length; i += 2) {\r\n    var range = utils.flatten(args[i]);\r\n    var criteria = args[i + 1];\r\n    if (!/[<>=!]/.test(criteria)) {\r\n      criteria = '==\"' + criteria + '\"';\r\n    }\r\n    for (var j = 0; j < range.length; j++) {\r\n      if (typeof range[j] !== 'string') {\r\n        results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line\r\n      } else {\r\n        results[j] = results[j] && eval('\"' + range[j] + '\"' + criteria); // jshint ignore:line\r\n      }\r\n    }\r\n  }\r\n  var result = 0;\r\n  for (i = 0; i < results.length; i++) {\r\n    if (results[i]) {\r\n      result++;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.COUNTUNIQUE = function () {\r\n  return misc.UNIQUE.apply(null, utils.flatten(arguments)).length;\r\n};\r\n\r\nexports.COVARIANCE = {};\r\n\r\nexports.COVARIANCE.P = function(array1, array2) {\r\n  array1 = utils.parseNumberArray(utils.flatten(array1));\r\n  array2 = utils.parseNumberArray(utils.flatten(array2));\r\n  if (utils.anyIsError(array1, array2)) {\r\n    return error.value;\r\n  }\r\n  var mean1 = jStat.mean(array1);\r\n  var mean2 = jStat.mean(array2);\r\n  var result = 0;\r\n  var n = array1.length;\r\n  for (var i = 0; i < n; i++) {\r\n    result += (array1[i] - mean1) * (array2[i] - mean2);\r\n  }\r\n  return result / n;\r\n};\r\n\r\nexports.COVARIANCE.S = function(array1, array2) {\r\n  array1 = utils.parseNumberArray(utils.flatten(array1));\r\n  array2 = utils.parseNumberArray(utils.flatten(array2));\r\n  if (utils.anyIsError(array1, array2)) {\r\n    return error.value;\r\n  }\r\n  return jStat.covariance(array1, array2);\r\n};\r\n\r\nexports.DEVSQ = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var mean = jStat.mean(range);\r\n  var result = 0;\r\n  for (var i = 0; i < range.length; i++) {\r\n    result += Math.pow((range[i] - mean), 2);\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.EXPON = {};\r\n\r\nexports.EXPON.DIST = function(x, lambda, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  lambda = utils.parseNumber(lambda);\r\n  if (utils.anyIsError(x, lambda)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);\r\n};\r\n\r\nexports.F = {};\r\n\r\nexports.F.DIST = function(x, d1, d2, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  d1 = utils.parseNumber(d1);\r\n  d2 = utils.parseNumber(d2);\r\n  if (utils.anyIsError(x, d1, d2)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);\r\n};\r\n\r\nexports.F.DIST.RT = function(x, d1, d2) {\r\n  if (arguments.length !== 3) {\r\n    return error.na;\r\n  }\r\n\r\n  if (x < 0 || d1 < 1 || d2 < 1) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof x !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return 1 - jStat.centralF.cdf(x, d1, d2);\r\n};\r\n\r\nexports.F.INV = function(probability, d1, d2) {\r\n  probability = utils.parseNumber(probability);\r\n  d1 = utils.parseNumber(d1);\r\n  d2 = utils.parseNumber(d2);\r\n  if (utils.anyIsError(probability, d1, d2)) {\r\n    return error.value;\r\n  }\r\n  if (probability <= 0.0 || probability > 1.0) {\r\n    return error.num;\r\n  }\r\n\r\n  return jStat.centralF.inv(probability, d1, d2);\r\n};\r\n\r\nexports.F.INV.RT = function(p, d1, d2) {\r\n  if (arguments.length !== 3) {\r\n    return error.na;\r\n  }\r\n\r\n  if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof p !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.centralF.inv(1.0 - p, d1, d2);\r\n};\r\n\r\nexports.F.TEST = function(array1, array2) {\r\n  if (!array1 || !array2) {\r\n    return error.na;\r\n  }\r\n\r\n  if (!(array1 instanceof Array) || !(array2 instanceof Array)) {\r\n    return error.na;\r\n  }\r\n\r\n  if (array1.length < 2 || array2.length < 2) {\r\n    return error.div0;\r\n  }\r\n\r\n  var sumOfSquares = function(values, x1) {\r\n    var sum = 0;\r\n    for (var i = 0; i < values.length; i++) {\r\n      sum +=Math.pow((values[i] - x1), 2);\r\n    }\r\n    return sum;\r\n  };\r\n\r\n  var x1 = mathTrig.SUM(array1) / array1.length;\r\n  var x2 = mathTrig.SUM(array2) / array2.length;\r\n  var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);\r\n  var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);\r\n\r\n  return sum1 / sum2;\r\n};\r\n\r\nexports.FISHER = function(x) {\r\n  x = utils.parseNumber(x);\r\n  if (x instanceof Error) {\r\n    return x;\r\n  }\r\n  return Math.log((1 + x) / (1 - x)) / 2;\r\n};\r\n\r\nexports.FISHERINV = function(y) {\r\n  y = utils.parseNumber(y);\r\n  if (y instanceof Error) {\r\n    return y;\r\n  }\r\n  var e2y = Math.exp(2 * y);\r\n  return (e2y - 1) / (e2y + 1);\r\n};\r\n\r\nexports.FORECAST = function(x, data_y, data_x) {\r\n  x = utils.parseNumber(x);\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  if (utils.anyIsError(x, data_y, data_x)) {\r\n    return error.value;\r\n  }\r\n  var xmean = jStat.mean(data_x);\r\n  var ymean = jStat.mean(data_y);\r\n  var n = data_x.length;\r\n  var num = 0;\r\n  var den = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    num += (data_x[i] - xmean) * (data_y[i] - ymean);\r\n    den += Math.pow(data_x[i] - xmean, 2);\r\n  }\r\n  var b = num / den;\r\n  var a = ymean - b * xmean;\r\n  return a + b * x;\r\n};\r\n\r\nexports.FREQUENCY = function(data, bins) {\r\n  data = utils.parseNumberArray(utils.flatten(data));\r\n  bins = utils.parseNumberArray(utils.flatten(bins));\r\n  if (utils.anyIsError(data, bins)) {\r\n    return error.value;\r\n  }\r\n  var n = data.length;\r\n  var b = bins.length;\r\n  var r = [];\r\n  for (var i = 0; i <= b; i++) {\r\n    r[i] = 0;\r\n    for (var j = 0; j < n; j++) {\r\n      if (i === 0) {\r\n        if (data[j] <= bins[0]) {\r\n          r[0] += 1;\r\n        }\r\n      } else if (i < b) {\r\n        if (data[j] > bins[i - 1] && data[j] <= bins[i]) {\r\n          r[i] += 1;\r\n        }\r\n      } else if (i === b) {\r\n        if (data[j] > bins[b - 1]) {\r\n          r[b] += 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return r;\r\n};\r\n\r\n\r\nexports.GAMMA = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n\r\n  if (number === 0) {\r\n    return error.num;\r\n  }\r\n\r\n  if (parseInt(number, 10) === number && number < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  return jStat.gammafn(number);\r\n};\r\n\r\nexports.GAMMA.DIST = function(value, alpha, beta, cumulative) {\r\n  if (arguments.length !== 4) {\r\n    return error.na;\r\n  }\r\n\r\n  if (value < 0 || alpha <= 0 || beta <= 0) {\r\n    return error.value;\r\n  }\r\n\r\n  if ((typeof value !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);\r\n};\r\n\r\nexports.GAMMA.INV = function(probability, alpha, beta) {\r\n  if (arguments.length !== 3) {\r\n    return error.na;\r\n  }\r\n\r\n  if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof probability !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.gamma.inv(probability, alpha, beta);\r\n};\r\n\r\nexports.GAMMALN = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return jStat.gammaln(number);\r\n};\r\n\r\nexports.GAMMALN.PRECISE = function(x) {\r\n  if (arguments.length !== 1) {\r\n    return error.na;\r\n  }\r\n\r\n  if (x <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  if (typeof x !== 'number') {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.gammaln(x);\r\n};\r\n\r\nexports.GAUSS = function(z) {\r\n  z = utils.parseNumber(z);\r\n  if (z instanceof Error) {\r\n    return z;\r\n  }\r\n  return jStat.normal.cdf(z, 0, 1) - 0.5;\r\n};\r\n\r\nexports.GEOMEAN = function() {\r\n  var args = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (args instanceof Error) {\r\n    return args;\r\n  }\r\n  return jStat.geomean(args);\r\n};\r\n\r\nexports.GROWTH = function(known_y, known_x, new_x, use_const) {\r\n  // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)\r\n\r\n  known_y = utils.parseNumberArray(known_y);\r\n  if (known_y instanceof Error) {\r\n    return known_y;\r\n  }\r\n\r\n  // Default values for optional parameters:\r\n  var i;\r\n  if (known_x === undefined) {\r\n    known_x = [];\r\n    for (i = 1; i <= known_y.length; i++) {\r\n      known_x.push(i);\r\n    }\r\n  }\r\n  if (new_x === undefined) {\r\n    new_x = [];\r\n    for (i = 1; i <= known_y.length; i++) {\r\n      new_x.push(i);\r\n    }\r\n  }\r\n\r\n  known_x = utils.parseNumberArray(known_x);\r\n  new_x = utils.parseNumberArray(new_x);\r\n  if (utils.anyIsError(known_x, new_x)) {\r\n    return error.value;\r\n  }\r\n\r\n\r\n  if (use_const === undefined) {\r\n    use_const = true;\r\n  }\r\n\r\n  // Calculate sums over the data:\r\n  var n = known_y.length;\r\n  var avg_x = 0;\r\n  var avg_y = 0;\r\n  var avg_xy = 0;\r\n  var avg_xx = 0;\r\n  for (i = 0; i < n; i++) {\r\n    var x = known_x[i];\r\n    var y = Math.log(known_y[i]);\r\n    avg_x += x;\r\n    avg_y += y;\r\n    avg_xy += x * y;\r\n    avg_xx += x * x;\r\n  }\r\n  avg_x /= n;\r\n  avg_y /= n;\r\n  avg_xy /= n;\r\n  avg_xx /= n;\r\n\r\n  // Compute linear regression coefficients:\r\n  var beta;\r\n  var alpha;\r\n  if (use_const) {\r\n    beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);\r\n    alpha = avg_y - beta * avg_x;\r\n  } else {\r\n    beta = avg_xy / avg_xx;\r\n    alpha = 0;\r\n  }\r\n\r\n  // Compute and return result array:\r\n  var new_y = [];\r\n  for (i = 0; i < new_x.length; i++) {\r\n    new_y.push(Math.exp(alpha + beta * new_x[i]));\r\n  }\r\n  return new_y;\r\n};\r\n\r\nexports.HARMEAN = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var n = range.length;\r\n  var den = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    den += 1 / range[i];\r\n  }\r\n  return n / den;\r\n};\r\n\r\nexports.HYPGEOM = {};\r\n\r\nexports.HYPGEOM.DIST = function(x, n, M, N, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  n = utils.parseNumber(n);\r\n  M = utils.parseNumber(M);\r\n  N = utils.parseNumber(N);\r\n  if (utils.anyIsError(x, n, M, N)) {\r\n    return error.value;\r\n  }\r\n\r\n  function pdf(x, n, M, N) {\r\n    return mathTrig.COMBIN(M, x) * mathTrig.COMBIN(N - M, n - x) / mathTrig.COMBIN(N, n);\r\n  }\r\n\r\n  function cdf(x, n, M, N) {\r\n    var result = 0;\r\n    for (var i = 0; i <= x; i++) {\r\n      result += pdf(i, n, M, N);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  return (cumulative) ? cdf(x, n, M, N) : pdf(x, n, M, N);\r\n};\r\n\r\nexports.INTERCEPT = function(known_y, known_x) {\r\n  known_y = utils.parseNumberArray(known_y);\r\n  known_x = utils.parseNumberArray(known_x);\r\n  if (utils.anyIsError(known_y, known_x)) {\r\n    return error.value;\r\n  }\r\n  if (known_y.length !== known_x.length) {\r\n    return error.na;\r\n  }\r\n  return exports.FORECAST(0, known_y, known_x);\r\n};\r\n\r\nexports.KURT = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var mean = jStat.mean(range);\r\n  var n = range.length;\r\n  var sigma = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    sigma += Math.pow(range[i] - mean, 4);\r\n  }\r\n  sigma = sigma / Math.pow(jStat.stdev(range, true), 4);\r\n  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));\r\n};\r\n\r\nexports.LARGE = function(range, k) {\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  k = utils.parseNumber(k);\r\n  if (utils.anyIsError(range, k)) {\r\n    return range;\r\n  }\r\n  return range.sort(function(a, b) {\r\n    return b - a;\r\n  })[k - 1];\r\n};\r\n\r\nexports.LINEST = function(data_y, data_x) {\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  if (utils.anyIsError(data_y, data_x)) {\r\n    return error.value;\r\n  }\r\n  var ymean = jStat.mean(data_y);\r\n  var xmean = jStat.mean(data_x);\r\n  var n = data_x.length;\r\n  var num = 0;\r\n  var den = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    num += (data_x[i] - xmean) * (data_y[i] - ymean);\r\n    den += Math.pow(data_x[i] - xmean, 2);\r\n  }\r\n  var m = num / den;\r\n  var b = ymean - m * xmean;\r\n  return [m, b];\r\n};\r\n\r\n// According to Microsoft:\r\n// http://office.microsoft.com/en-us/starter-help/logest-function-HP010342665.aspx\r\n// LOGEST returns are based on the following linear model:\r\n// ln y = x1 ln m1 + ... + xn ln mn + ln b\r\nexports.LOGEST = function(data_y, data_x) {\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  if (utils.anyIsError(data_y, data_x)) {\r\n    return error.value;\r\n  }\r\n  for (var i = 0; i < data_y.length; i ++) {\r\n    data_y[i] = Math.log(data_y[i]);\r\n  }\r\n\r\n  var result = exports.LINEST(data_y, data_x);\r\n  result[0] = Math.round(Math.exp(result[0])*1000000)/1000000;\r\n  result[1] = Math.round(Math.exp(result[1])*1000000)/1000000;\r\n  return result;\r\n};\r\n\r\nexports.LOGNORM = {};\r\n\r\nexports.LOGNORM.DIST = function(x, mean, sd, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  mean = utils.parseNumber(mean);\r\n  sd = utils.parseNumber(sd);\r\n  if (utils.anyIsError(x, mean, sd)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.lognormal.cdf(x, mean, sd) : jStat.lognormal.pdf(x, mean, sd);\r\n};\r\n\r\nexports.LOGNORM.INV = function(probability, mean, sd) {\r\n  probability = utils.parseNumber(probability);\r\n  mean = utils.parseNumber(mean);\r\n  sd = utils.parseNumber(sd);\r\n  if (utils.anyIsError(probability, mean, sd)) {\r\n    return error.value;\r\n  }\r\n  return jStat.lognormal.inv(probability, mean, sd);\r\n};\r\n\r\nexports.MAX = function() {\r\n  var range = utils.numbers(utils.flatten(arguments));\r\n  return (range.length === 0) ? 0 : Math.max.apply(Math, range);\r\n};\r\n\r\nexports.MAXA = function() {\r\n  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));\r\n  return (range.length === 0) ? 0 : Math.max.apply(Math, range);\r\n};\r\n\r\nexports.MEDIAN = function() {\r\n  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));\r\n  var result = jStat.median(range);\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.MIN = function() {\r\n  var range = utils.numbers(utils.flatten(arguments));\r\n  return (range.length === 0) ? 0 : Math.min.apply(Math, range);\r\n};\r\n\r\nexports.MINA = function() {\r\n  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));\r\n  return (range.length === 0) ? 0 : Math.min.apply(Math, range);\r\n};\r\n\r\nexports.MODE = {};\r\n\r\nexports.MODE.MULT = function() {\r\n  // Credits: Ronan\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var n = range.length;\r\n  var count = {};\r\n  var maxItems = [];\r\n  var max = 0;\r\n  var currentItem;\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    currentItem = range[i];\r\n    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;\r\n    if (count[currentItem] > max) {\r\n      max = count[currentItem];\r\n      maxItems = [];\r\n    }\r\n    if (count[currentItem] === max) {\r\n      maxItems[maxItems.length] = currentItem;\r\n    }\r\n  }\r\n  return maxItems;\r\n};\r\n\r\nexports.MODE.SNGL = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  return exports.MODE.MULT(range).sort(function(a, b) {\r\n    return a - b;\r\n  })[0];\r\n};\r\n\r\nexports.NEGBINOM = {};\r\n\r\nexports.NEGBINOM.DIST = function(k, r, p, cumulative) {\r\n  k = utils.parseNumber(k);\r\n  r = utils.parseNumber(r);\r\n  p = utils.parseNumber(p);\r\n  if (utils.anyIsError(k, r, p)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.negbin.cdf(k, r, p) : jStat.negbin.pdf(k, r, p);\r\n};\r\n\r\nexports.NORM = {};\r\n\r\nexports.NORM.DIST = function(x, mean, sd, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  mean = utils.parseNumber(mean);\r\n  sd = utils.parseNumber(sd);\r\n  if (utils.anyIsError(x, mean, sd)) {\r\n    return error.value;\r\n  }\r\n  if (sd <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return normal distribution computed by jStat [http://jstat.org]\r\n  return (cumulative) ? jStat.normal.cdf(x, mean, sd) : jStat.normal.pdf(x, mean, sd);\r\n};\r\n\r\nexports.NORM.INV = function(probability, mean, sd) {\r\n  probability = utils.parseNumber(probability);\r\n  mean = utils.parseNumber(mean);\r\n  sd = utils.parseNumber(sd);\r\n  if (utils.anyIsError(probability, mean, sd)) {\r\n    return error.value;\r\n  }\r\n  return jStat.normal.inv(probability, mean, sd);\r\n};\r\n\r\nexports.NORM.S = {};\r\n\r\nexports.NORM.S.DIST = function(z, cumulative) {\r\n  z = utils.parseNumber(z);\r\n  if (z instanceof Error) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);\r\n};\r\n\r\nexports.NORM.S.INV = function(probability) {\r\n  probability = utils.parseNumber(probability);\r\n  if (probability instanceof Error) {\r\n    return error.value;\r\n  }\r\n  return jStat.normal.inv(probability, 0, 1);\r\n};\r\n\r\nexports.PEARSON = function(data_x, data_y) {\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  if (utils.anyIsError(data_y, data_x)) {\r\n    return error.value;\r\n  }\r\n  var xmean = jStat.mean(data_x);\r\n  var ymean = jStat.mean(data_y);\r\n  var n = data_x.length;\r\n  var num = 0;\r\n  var den1 = 0;\r\n  var den2 = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    num += (data_x[i] - xmean) * (data_y[i] - ymean);\r\n    den1 += Math.pow(data_x[i] - xmean, 2);\r\n    den2 += Math.pow(data_y[i] - ymean, 2);\r\n  }\r\n  return num / Math.sqrt(den1 * den2);\r\n};\r\n\r\nexports.PERCENTILE = {};\r\n\r\nexports.PERCENTILE.EXC = function(array, k) {\r\n  array = utils.parseNumberArray(utils.flatten(array));\r\n  k = utils.parseNumber(k);\r\n  if (utils.anyIsError(array, k)) {\r\n    return error.value;\r\n  }\r\n  array = array.sort(function(a, b) {\r\n    {\r\n      return a - b;\r\n    }\r\n  });\r\n  var n = array.length;\r\n  if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {\r\n    return error.num;\r\n  }\r\n  var l = k * (n + 1) - 1;\r\n  var fl = Math.floor(l);\r\n  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));\r\n};\r\n\r\nexports.PERCENTILE.INC = function(array, k) {\r\n  array = utils.parseNumberArray(utils.flatten(array));\r\n  k = utils.parseNumber(k);\r\n  if (utils.anyIsError(array, k)) {\r\n    return error.value;\r\n  }\r\n  array = array.sort(function(a, b) {\r\n    return a - b;\r\n  });\r\n  var n = array.length;\r\n  var l = k * (n - 1);\r\n  var fl = Math.floor(l);\r\n  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));\r\n};\r\n\r\nexports.PERCENTRANK = {};\r\n\r\nexports.PERCENTRANK.EXC = function(array, x, significance) {\r\n  significance = (significance === undefined) ? 3 : significance;\r\n  array = utils.parseNumberArray(utils.flatten(array));\r\n  x = utils.parseNumber(x);\r\n  significance = utils.parseNumber(significance);\r\n  if (utils.anyIsError(array, x, significance)) {\r\n    return error.value;\r\n  }\r\n  array = array.sort(function(a, b) {\r\n    return a - b;\r\n  });\r\n  var uniques = misc.UNIQUE.apply(null, array);\r\n  var n = array.length;\r\n  var m = uniques.length;\r\n  var power = Math.pow(10, significance);\r\n  var result = 0;\r\n  var match = false;\r\n  var i = 0;\r\n  while (!match && i < m) {\r\n    if (x === uniques[i]) {\r\n      result = (array.indexOf(uniques[i]) + 1) / (n + 1);\r\n      match = true;\r\n    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {\r\n      result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);\r\n      match = true;\r\n    }\r\n    i++;\r\n  }\r\n  return Math.floor(result * power) / power;\r\n};\r\n\r\nexports.PERCENTRANK.INC = function(array, x, significance) {\r\n  significance = (significance === undefined) ? 3 : significance;\r\n  array = utils.parseNumberArray(utils.flatten(array));\r\n  x = utils.parseNumber(x);\r\n  significance = utils.parseNumber(significance);\r\n  if (utils.anyIsError(array, x, significance)) {\r\n    return error.value;\r\n  }\r\n  array = array.sort(function(a, b) {\r\n    return a - b;\r\n  });\r\n  var uniques = misc.UNIQUE.apply(null, array);\r\n  var n = array.length;\r\n  var m = uniques.length;\r\n  var power = Math.pow(10, significance);\r\n  var result = 0;\r\n  var match = false;\r\n  var i = 0;\r\n  while (!match && i < m) {\r\n    if (x === uniques[i]) {\r\n      result = array.indexOf(uniques[i]) / (n - 1);\r\n      match = true;\r\n    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {\r\n      result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);\r\n      match = true;\r\n    }\r\n    i++;\r\n  }\r\n  return Math.floor(result * power) / power;\r\n};\r\n\r\nexports.PERMUT = function(number, number_chosen) {\r\n  number = utils.parseNumber(number);\r\n  number_chosen = utils.parseNumber(number_chosen);\r\n  if (utils.anyIsError(number, number_chosen)) {\r\n    return error.value;\r\n  }\r\n  return mathTrig.FACT(number) / mathTrig.FACT(number - number_chosen);\r\n};\r\n\r\nexports.PERMUTATIONA = function(number, number_chosen) {\r\n  number = utils.parseNumber(number);\r\n  number_chosen = utils.parseNumber(number_chosen);\r\n  if (utils.anyIsError(number, number_chosen)) {\r\n    return error.value;\r\n  }\r\n  return Math.pow(number, number_chosen);\r\n};\r\n\r\nexports.PHI = function(x) {\r\n  x = utils.parseNumber(x);\r\n  if (x instanceof Error) {\r\n    return error.value;\r\n  }\r\n  return Math.exp(-0.5 * x * x) / SQRT2PI;\r\n};\r\n\r\nexports.POISSON = {};\r\n\r\nexports.POISSON.DIST = function(x, mean, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  mean = utils.parseNumber(mean);\r\n  if (utils.anyIsError(x, mean)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);\r\n};\r\n\r\nexports.PROB = function(range, probability, lower, upper) {\r\n  if (lower === undefined) {\r\n    return 0;\r\n  }\r\n  upper = (upper === undefined) ? lower : upper;\r\n\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  probability = utils.parseNumberArray(utils.flatten(probability));\r\n  lower = utils.parseNumber(lower);\r\n  upper = utils.parseNumber(upper);\r\n  if (utils.anyIsError(range, probability, lower, upper)) {\r\n    return error.value;\r\n  }\r\n\r\n  if (lower === upper) {\r\n    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;\r\n  }\r\n\r\n  var sorted = range.sort(function(a, b) {\r\n    return a - b;\r\n  });\r\n  var n = sorted.length;\r\n  var result = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    if (sorted[i] >= lower && sorted[i] <= upper) {\r\n      result += probability[range.indexOf(sorted[i])];\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.QUARTILE = {};\r\n\r\nexports.QUARTILE.EXC = function(range, quart) {\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  quart = utils.parseNumber(quart);\r\n  if (utils.anyIsError(range, quart)) {\r\n    return error.value;\r\n  }\r\n  switch (quart) {\r\n    case 1:\r\n      return exports.PERCENTILE.EXC(range, 0.25);\r\n    case 2:\r\n      return exports.PERCENTILE.EXC(range, 0.5);\r\n    case 3:\r\n      return exports.PERCENTILE.EXC(range, 0.75);\r\n    default:\r\n      return error.num;\r\n  }\r\n};\r\n\r\nexports.QUARTILE.INC = function(range, quart) {\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  quart = utils.parseNumber(quart);\r\n  if (utils.anyIsError(range, quart)) {\r\n    return error.value;\r\n  }\r\n  switch (quart) {\r\n    case 1:\r\n      return exports.PERCENTILE.INC(range, 0.25);\r\n    case 2:\r\n      return exports.PERCENTILE.INC(range, 0.5);\r\n    case 3:\r\n      return exports.PERCENTILE.INC(range, 0.75);\r\n    default:\r\n      return error.num;\r\n  }\r\n};\r\n\r\nexports.RANK = {};\r\n\r\nexports.RANK.AVG = function(number, range, order) {\r\n  number = utils.parseNumber(number);\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  if (utils.anyIsError(number, range)) {\r\n    return error.value;\r\n  }\r\n  range = utils.flatten(range);\r\n  order = order || false;\r\n  var sort = (order) ? function(a, b) {\r\n    return a - b;\r\n  } : function(a, b) {\r\n    return b - a;\r\n  };\r\n  range = range.sort(sort);\r\n\r\n  var length = range.length;\r\n  var count = 0;\r\n  for (var i = 0; i < length; i++) {\r\n    if (range[i] === number) {\r\n      count++;\r\n    }\r\n  }\r\n\r\n  return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;\r\n};\r\n\r\nexports.RANK.EQ = function(number, range, order) {\r\n  number = utils.parseNumber(number);\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  if (utils.anyIsError(number, range)) {\r\n    return error.value;\r\n  }\r\n  order = order || false;\r\n  var sort = (order) ? function(a, b) {\r\n    return a - b;\r\n  } : function(a, b) {\r\n    return b - a;\r\n  };\r\n  range = range.sort(sort);\r\n  return range.indexOf(number) + 1;\r\n};\r\n\r\nexports.ROW = function(matrix, index) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  if (index < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  if (!(matrix instanceof Array) || (typeof index !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  if (matrix.length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return jStat.row(matrix, index);\r\n};\r\n\r\nexports.ROWS = function(matrix) {\r\n  if (arguments.length !== 1) {\r\n    return error.na;\r\n  }\r\n\r\n  if (!(matrix instanceof Array)) {\r\n    return error.value;\r\n  }\r\n\r\n  if (matrix.length === 0) {\r\n    return 0;\r\n  }\r\n\r\n  return jStat.rows(matrix);\r\n};\r\n\r\nexports.RSQ = function(data_x, data_y) { // no need to flatten here, PEARSON will take care of that\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  if (utils.anyIsError(data_x, data_y)) {\r\n    return error.value;\r\n  }\r\n  return Math.pow(exports.PEARSON(data_x, data_y), 2);\r\n};\r\n\r\nexports.SKEW = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var mean = jStat.mean(range);\r\n  var n = range.length;\r\n  var sigma = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    sigma += Math.pow(range[i] - mean, 3);\r\n  }\r\n  return n * sigma / ((n - 1) * (n - 2) * Math.pow(jStat.stdev(range, true), 3));\r\n};\r\n\r\nexports.SKEW.P = function() {\r\n  var range = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (range instanceof Error) {\r\n    return range;\r\n  }\r\n  var mean = jStat.mean(range);\r\n  var n = range.length;\r\n  var m2 = 0;\r\n  var m3 = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    m3 += Math.pow(range[i] - mean, 3);\r\n    m2 += Math.pow(range[i] - mean, 2);\r\n  }\r\n  m3 = m3 / n;\r\n  m2 = m2 / n;\r\n  return m3 / Math.pow(m2, 3 / 2);\r\n};\r\n\r\nexports.SLOPE = function(data_y, data_x) {\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  if (utils.anyIsError(data_y, data_x)) {\r\n    return error.value;\r\n  }\r\n  var xmean = jStat.mean(data_x);\r\n  var ymean = jStat.mean(data_y);\r\n  var n = data_x.length;\r\n  var num = 0;\r\n  var den = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    num += (data_x[i] - xmean) * (data_y[i] - ymean);\r\n    den += Math.pow(data_x[i] - xmean, 2);\r\n  }\r\n  return num / den;\r\n};\r\n\r\nexports.SMALL = function(range, k) {\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  k = utils.parseNumber(k);\r\n  if (utils.anyIsError(range, k)) {\r\n    return range;\r\n  }\r\n  return range.sort(function(a, b) {\r\n    return a - b;\r\n  })[k - 1];\r\n};\r\n\r\nexports.STANDARDIZE = function(x, mean, sd) {\r\n  x = utils.parseNumber(x);\r\n  mean = utils.parseNumber(mean);\r\n  sd = utils.parseNumber(sd);\r\n  if (utils.anyIsError(x, mean, sd)) {\r\n    return error.value;\r\n  }\r\n  return (x - mean) / sd;\r\n};\r\n\r\nexports.STDEV = {};\r\n\r\nexports.STDEV.P = function() {\r\n  var v = exports.VAR.P.apply(this, arguments);\r\n  var result = Math.sqrt(v);\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.STDEV.S = function() {\r\n  var v = exports.VAR.S.apply(this, arguments);\r\n  var result = Math.sqrt(v);\r\n\r\n  return result;\r\n};\r\n\r\nexports.STDEVA = function() {\r\n  var v = exports.VARA.apply(this, arguments);\r\n  var result = Math.sqrt(v);\r\n\r\n  return result;\r\n};\r\n\r\nexports.STDEVPA = function() {\r\n  var v = exports.VARPA.apply(this, arguments);\r\n  var result = Math.sqrt(v);\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n\r\nexports.STEYX = function(data_y, data_x) {\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  if (utils.anyIsError(data_y, data_x)) {\r\n    return error.value;\r\n  }\r\n  var xmean = jStat.mean(data_x);\r\n  var ymean = jStat.mean(data_y);\r\n  var n = data_x.length;\r\n  var lft = 0;\r\n  var num = 0;\r\n  var den = 0;\r\n  for (var i = 0; i < n; i++) {\r\n    lft += Math.pow(data_y[i] - ymean, 2);\r\n    num += (data_x[i] - xmean) * (data_y[i] - ymean);\r\n    den += Math.pow(data_x[i] - xmean, 2);\r\n  }\r\n  return Math.sqrt((lft - num * num / den) / (n - 2));\r\n};\r\n\r\nexports.TRANSPOSE = function(matrix) {\r\n  if (!matrix) {\r\n    return error.na;\r\n  }\r\n  return jStat.transpose(matrix);\r\n};\r\n\r\nexports.T = text.T;\r\n\r\nexports.T.DIST = function(x, df, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  df = utils.parseNumber(df);\r\n  if (utils.anyIsError(x, df)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? jStat.studentt.cdf(x, df) : jStat.studentt.pdf(x, df);\r\n};\r\n\r\nexports.T.DIST['2T'] = function(x, df) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  if (x < 0 || df < 1) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof x !== 'number') || (typeof df !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return (1 - jStat.studentt.cdf(x , df)) * 2;\r\n};\r\n\r\nexports.T.DIST.RT = function(x, df) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n\r\n  if (x < 0 || df < 1) {\r\n    return error.num;\r\n  }\r\n\r\n  if ((typeof x !== 'number') || (typeof df !== 'number')) {\r\n    return error.value;\r\n  }\r\n\r\n  return 1 - jStat.studentt.cdf(x , df);\r\n};\r\n\r\nexports.T.INV = function(probability, df) {\r\n  probability = utils.parseNumber(probability);\r\n  df = utils.parseNumber(df);\r\n  if (utils.anyIsError(probability, df)) {\r\n    return error.value;\r\n  }\r\n  return jStat.studentt.inv(probability, df);\r\n};\r\n\r\nexports.T.INV['2T'] = function(probability, df) {\r\n  probability = utils.parseNumber(probability);\r\n  df = utils.parseNumber(df);\r\n  if (probability <= 0 || probability > 1 || df < 1) {\r\n    return error.num;\r\n  }\r\n  if (utils.anyIsError(probability, df)) {\r\n    return error.value;\r\n  }\r\n  return Math.abs(jStat.studentt.inv(probability/2, df));\r\n};\r\n\r\n// The algorithm can be found here:\r\n// http://www.chem.uoa.gr/applets/AppletTtest/Appl_Ttest2.html\r\nexports.T.TEST = function(data_x, data_y) {\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  if (utils.anyIsError(data_x, data_y)) {\r\n    return error.value;\r\n  }\r\n\r\n  var mean_x = jStat.mean(data_x);\r\n  var mean_y = jStat.mean(data_y);\r\n  var s_x = 0;\r\n  var s_y = 0;\r\n  var i;\r\n\r\n  for (i = 0; i < data_x.length; i++) {\r\n    s_x += Math.pow(data_x[i] - mean_x, 2);\r\n  }\r\n  for (i = 0; i < data_y.length; i++) {\r\n    s_y += Math.pow(data_y[i] - mean_y, 2);\r\n  }\r\n\r\n  s_x = s_x / (data_x.length-1);\r\n  s_y = s_y / (data_y.length-1);\r\n\r\n  var t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x/data_x.length + s_y/data_y.length);\r\n\r\n  return exports.T.DIST['2T'](t, data_x.length+data_y.length-2);\r\n};\r\n\r\nexports.TREND = function(data_y, data_x, new_data_x) {\r\n  data_y = utils.parseNumberArray(utils.flatten(data_y));\r\n  data_x = utils.parseNumberArray(utils.flatten(data_x));\r\n  new_data_x = utils.parseNumberArray(utils.flatten(new_data_x));\r\n  if (utils.anyIsError(data_y, data_x, new_data_x)) {\r\n    return error.value;\r\n  }\r\n  var linest = exports.LINEST(data_y, data_x);\r\n  var m = linest[0];\r\n  var b = linest[1];\r\n  var result = [];\r\n\r\n  new_data_x.forEach(function(x) {\r\n    result.push(m * x + b);\r\n  });\r\n\r\n  return result;\r\n};\r\n\r\nexports.TRIMMEAN = function(range, percent) {\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  percent = utils.parseNumber(percent);\r\n  if (utils.anyIsError(range, percent)) {\r\n    return error.value;\r\n  }\r\n  var trim = mathTrig.FLOOR(range.length * percent, 2) / 2;\r\n  return jStat.mean(utils.initial(utils.rest(range.sort(function(a, b) {\r\n    return a - b;\r\n  }), trim), trim));\r\n};\r\n\r\nexports.VAR = {};\r\n\r\nexports.VAR.P = function() {\r\n  var range = utils.numbers(utils.flatten(arguments));\r\n  var n = range.length;\r\n  var sigma = 0;\r\n  var mean = exports.AVERAGE(range);\r\n  var result;\r\n  for (var i = 0; i < n; i++) {\r\n    sigma += Math.pow(range[i] - mean, 2);\r\n  }\r\n  result = sigma / n;\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.VAR.S = function() {\r\n  var range = utils.numbers(utils.flatten(arguments));\r\n  var n = range.length;\r\n  var sigma = 0;\r\n  var mean = exports.AVERAGE(range);\r\n  for (var i = 0; i < n; i++) {\r\n    sigma += Math.pow(range[i] - mean, 2);\r\n  }\r\n  return sigma / (n - 1);\r\n};\r\n\r\nexports.VARA = function() {\r\n  var range = utils.flatten(arguments);\r\n  var n = range.length;\r\n  var sigma = 0;\r\n  var count = 0;\r\n  var mean = exports.AVERAGEA(range);\r\n  for (var i = 0; i < n; i++) {\r\n    var el = range[i];\r\n    if (typeof el === 'number') {\r\n      sigma += Math.pow(el - mean, 2);\r\n    } else if (el === true) {\r\n      sigma += Math.pow(1 - mean, 2);\r\n    } else {\r\n      sigma += Math.pow(0 - mean, 2);\r\n    }\r\n\r\n    if (el !== null) {\r\n      count++;\r\n    }\r\n  }\r\n  return sigma / (count - 1);\r\n};\r\n\r\nexports.VARPA = function() {\r\n  var range = utils.flatten(arguments);\r\n  var n = range.length;\r\n  var sigma = 0;\r\n  var count = 0;\r\n  var mean = exports.AVERAGEA(range);\r\n  var result;\r\n  for (var i = 0; i < n; i++) {\r\n    var el = range[i];\r\n    if (typeof el === 'number') {\r\n      sigma += Math.pow(el - mean, 2);\r\n    } else if (el === true) {\r\n      sigma += Math.pow(1 - mean, 2);\r\n    } else {\r\n      sigma += Math.pow(0 - mean, 2);\r\n    }\r\n\r\n    if (el !== null) {\r\n      count++;\r\n    }\r\n  }\r\n  result = sigma / count;\r\n\r\n  if (isNaN(result)) {\r\n    result = error.num;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.WEIBULL = {};\r\n\r\nexports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {\r\n  x = utils.parseNumber(x);\r\n  alpha = utils.parseNumber(alpha);\r\n  beta = utils.parseNumber(beta);\r\n  if (utils.anyIsError(x, alpha, beta)) {\r\n    return error.value;\r\n  }\r\n  return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);\r\n};\r\n\r\nexports.Z = {};\r\n\r\nexports.Z.TEST = function(range, x, sd) {\r\n  range = utils.parseNumberArray(utils.flatten(range));\r\n  x = utils.parseNumber(x);\r\n  if (utils.anyIsError(range, x)) {\r\n    return error.value;\r\n  }\r\n\r\n  sd = sd || exports.STDEV.S(range);\r\n  var n = range.length;\r\n  return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/statistical.js\n// module id = 19\n// module chunks = 0","var utils = require('./utils');\r\nvar error = require('./error');\r\n\r\n//TODO\r\nexports.ASC = function() {\r\n  throw new Error('ASC is not implemented');\r\n};\r\n\r\n//TODO\r\nexports.BAHTTEXT = function() {\r\n  throw new Error('BAHTTEXT is not implemented');\r\n};\r\n\r\nexports.CHAR = function(number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return String.fromCharCode(number);\r\n};\r\n\r\nexports.CLEAN = function(text) {\r\n  text = text || '';\r\n  var re = /[\\0-\\x1F]/g;\r\n  return text.replace(re, \"\");\r\n};\r\n\r\nexports.CODE = function(text) {\r\n  text = text || '';\r\n  var result = text.charCodeAt(0);\r\n\r\n  if (isNaN(result)) {\r\n    result = error.na;\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.CONCATENATE = function() {\r\n  var args = utils.flatten(arguments);\r\n\r\n  var trueFound = 0;\r\n  while ((trueFound = args.indexOf(true)) > -1) {\r\n    args[trueFound] = 'TRUE';\r\n  }\r\n\r\n  var falseFound = 0;\r\n  while ((falseFound = args.indexOf(false)) > -1) {\r\n    args[falseFound] = 'FALSE';\r\n  }\r\n\r\n  return args.join('');\r\n};\r\n\r\n//TODO\r\nexports.DBCS = function() {\r\n  throw new Error('DBCS is not implemented');\r\n};\r\n\r\n//TODO\r\nexports.DOLLAR = function() {\r\n  throw new Error('DOLLAR is not implemented');\r\n};\r\n\r\nexports.EXACT = function(text1, text2) {\r\n  if (arguments.length !== 2) {\r\n    return error.na;\r\n  }\r\n  return text1 === text2;\r\n};\r\n\r\nexports.FIND = function(find_text, within_text, position) {\r\n  if (arguments.length < 2) {\r\n    return error.na;\r\n  }\r\n  position = (position === undefined) ? 0 : position;\r\n  return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;\r\n};\r\n\r\n//TODO\r\nexports.FIXED = function() {\r\n  throw new Error('FIXED is not implemented');\r\n};\r\n\r\nexports.HTML2TEXT = function (value) {\r\n  var result = '';\r\n\r\n  if (value) {\r\n    if (value instanceof Array) {\r\n      value.forEach(function (line) {\r\n        if (result !== '') {\r\n          result += '\\n';\r\n        }\r\n        result += (line.replace(/<(?:.|\\n)*?>/gm, ''));\r\n      });\r\n    } else {\r\n      result = value.replace(/<(?:.|\\n)*?>/gm, '');\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.LEFT = function(text, number) {\r\n  number = (number === undefined) ? 1 : number;\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error || typeof text !== 'string') {\r\n    return error.value;\r\n  }\r\n  return text ? text.substring(0, number) : null;\r\n};\r\n\r\nexports.LEN = function(text) {\r\n  if (arguments.length === 0) {\r\n    return error.error;\r\n  }\r\n\r\n  if (typeof text === 'string') {\r\n    return text ? text.length : 0;\r\n  }\r\n\r\n  if (text.length) {\r\n    return text.length;\r\n  }\r\n\r\n  return error.value;\r\n};\r\n\r\nexports.LOWER = function(text) {\r\n  if (typeof text !== 'string') {\r\n    return error.value;\r\n  }\r\n  return text ? text.toLowerCase() : text;\r\n};\r\n\r\nexports.MID = function(text, start, number) {\r\n  start = utils.parseNumber(start);\r\n  number = utils.parseNumber(number);\r\n  if (utils.anyIsError(start, number) || typeof text !== 'string') {\r\n    return number;\r\n  }\r\n\r\n  var begin = start - 1;\r\n  var end = begin + number;\r\n\r\n  return text.substring(begin, end);\r\n};\r\n\r\n// TODO\r\nexports.NUMBERVALUE = function (text, decimal_separator, group_separator)  {\r\n  decimal_separator = (typeof decimal_separator === 'undefined') ? '.' : decimal_separator;\r\n  group_separator = (typeof group_separator === 'undefined') ? ',' : group_separator;\r\n  return Number(text.replace(decimal_separator, '.').replace(group_separator, ''));\r\n};\r\n\r\n// TODO\r\nexports.PRONETIC = function() {\r\n  throw new Error('PRONETIC is not implemented');\r\n};\r\n\r\nexports.PROPER = function(text) {\r\n  if (text === undefined || text.length === 0) {\r\n    return error.value;\r\n  }\r\n  if (text === true) {\r\n    text = 'TRUE';\r\n  }\r\n  if (text === false) {\r\n    text = 'FALSE';\r\n  }\r\n  if (isNaN(text) && typeof text === 'number') {\r\n    return error.value;\r\n  }\r\n  if (typeof text === 'number') {\r\n    text = '' + text;\r\n  }\r\n\r\n  return text.replace(/\\w\\S*/g, function(txt) {\r\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\r\n  });\r\n};\r\n\r\nexports.REGEXEXTRACT = function (text, regular_expression) {\r\n  if (arguments.length < 2) {\r\n    return error.na;\r\n  }\r\n  var match = text.match(new RegExp(regular_expression));\r\n  return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;\r\n};\r\n\r\nexports.REGEXMATCH = function (text, regular_expression, full) {\r\n  if (arguments.length < 2) {\r\n    return error.na;\r\n  }\r\n  var match = text.match(new RegExp(regular_expression));\r\n  return full ? match : !!match;\r\n};\r\n\r\nexports.REGEXREPLACE = function (text, regular_expression, replacement) {\r\n  if (arguments.length < 3) {\r\n    return error.na;\r\n  }\r\n  return text.replace(new RegExp(regular_expression), replacement);\r\n};\r\n\r\nexports.REPLACE = function(text, position, length, new_text) {\r\n  position = utils.parseNumber(position);\r\n  length = utils.parseNumber(length);\r\n  if (utils.anyIsError(position, length) ||\r\n    typeof text !== 'string' ||\r\n    typeof new_text !== 'string') {\r\n    return error.value;\r\n  }\r\n  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);\r\n};\r\n\r\nexports.REPT = function(text, number) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return new Array(number + 1).join(text);\r\n};\r\n\r\nexports.RIGHT = function(text, number) {\r\n  number = (number === undefined) ? 1 : number;\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n  return text ? text.substring(text.length - number) : error.na;\r\n};\r\n\r\nexports.SEARCH = function(find_text, within_text, position) {\r\n  var foundAt;\r\n  if (typeof find_text !== 'string' || typeof within_text !== 'string') {\r\n    return error.value;\r\n  }\r\n  position = (position === undefined) ? 0 : position;\r\n  foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1)+1;\r\n  return (foundAt === 0)?error.value:foundAt;\r\n};\r\n\r\nexports.SPLIT = function (text, separator) {\r\n  return text.split(separator);\r\n};\r\n\r\nexports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {\r\n  if (arguments.length < 2) {\r\n    return error.na;\r\n  }\r\n  if (!text || !old_text || !new_text) {\r\n    return text;\r\n  } else if (occurrence === undefined) {\r\n    return text.replace(new RegExp(old_text, 'g'), new_text);\r\n  } else {\r\n    var index = 0;\r\n    var i = 0;\r\n    while (text.indexOf(old_text, index) > 0) {\r\n      index = text.indexOf(old_text, index + 1);\r\n      i++;\r\n      if (i === occurrence) {\r\n        return text.substring(0, index) + new_text + text.substring(index + old_text.length);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexports.T = function(value) {\r\n  return (typeof value === \"string\") ? value : '';\r\n};\r\n\r\n// TODO incomplete implementation\r\nexports.TEXT = function() {\r\n  throw new Error('TEXT is not implemented');\r\n};\r\n\r\nexports.TRIM = function(text) {\r\n  if (typeof text !== 'string') {\r\n    return error.value;\r\n  }\r\n  return text.replace(/ +/g, ' ').trim();\r\n};\r\n\r\nexports.UNICHAR = exports.CHAR;\r\n\r\nexports.UNICODE = exports.CODE;\r\n\r\nexports.UPPER = function(text) {\r\n  if (typeof text !== 'string') {\r\n    return error.value;\r\n  }\r\n  return text.toUpperCase();\r\n};\r\n\r\n//TODO\r\nexports.VALUE = function() {\r\n  throw new Error('VALUE is not implemented');\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/text.js\n// module id = 20\n// module chunks = 0","(function (window, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        window.jStat = factory();\n    }\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(arg) {\n  return typeof arg === 'number' && arg === arg;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  var i;\n\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (var i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function(i) {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (var i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (var i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, Math.random);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var issymmetric = true;\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      var colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      var rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    var rowSlice = rcSlice.row || {};\n    var colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    var nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    var ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  var ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  var nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = new Function(\n        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  return Math.pow(jStat.product(arr), 1 / arr.length);\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (var i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var arrlen = arr.length;\n  var sorted = arr.slice().sort(ascNum);\n  var ranks = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    var first = sorted.indexOf(arr[i]);\n    var last = sorted.lastIndexOf(arr[i]);\n    if (first === last) {\n      var val = first;\n    } else {\n      var val = (first + last) / 2;\n    }\n    ranks[i] = val + 1;\n  }\n  return ranks;\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (var i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (var i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Returns the k-th percentile of values in a range, where k is in the\n// range 0..1, exclusive.\njStat.percentile = function percentile(arr, k) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length - 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n\n  if (index + 1 < _arr.length) {\n    return _arr[index] * (1 - frac) + _arr[index + 1] * frac;\n  } else {\n    return _arr[index];\n  }\n}\n\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (var i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, bins) {\n  var first = jStat.min(arr);\n  var binCnt = bins || 4;\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (var i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (var i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (var i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        var callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        var callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res, sum, ysq;\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (var i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (var i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an, endval;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q, mat;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = Math.random();\n    v = 1.7156 * (Math.random() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = Math.random();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = Math.random();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function(a, b, c) {\n      if (!(this instanceof arguments.callee))\n        return new arguments.callee(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local, scale) {\n    return local;\n  },\n\n  mode: function mode(local, scale) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(rate) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(Math.random());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(alpha, beta) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu, sigma) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean, std) {\n    return mean;\n  },\n\n  median: function median(mean, std) {\n    return mean;\n  },\n\n  mode: function (mean, std) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale, shape) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(dof) {\n    return 0;\n  },\n\n  mode: function mode(dof) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var binomarr = [],\n    k = 0;\n    if (x < 0) {\n      return 0;\n    }\n    if (x < n) {\n      for (; k <= x; k++) {\n        binomarr[ k ] = jStat.binomial.pdf(k, n, p);\n      }\n      return jStat.sum(binomarr);\n    }\n    return 1;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sample: function sample(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= Math.random();\n    } while (p > L);\n    return k - 1;\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = Math.random();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu, b) {\n    return mu;\n  },\n\n  median: function(mu, b) {\n    return mu;\n  },\n\n  mode: function(mu, b) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = Math.random() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    for (var i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (var i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    var alen = a.length,\n    alend = alen * 2,\n    vals = new Array(alend),\n    rowshift = alen - 1,\n    colshift = alend - 1,\n    mrow = rowshift - alen + 1,\n    mcol = colshift,\n    i = 0,\n    result = 0,\n    j;\n    // check for special 2x2 case\n    if (alen === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n    for (; i < alend; i++) {\n      vals[i] = 1;\n    }\n    for (var i = 0; i < alen; i++) {\n      for (j = 0; j < alen; j++) {\n        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];\n        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];\n        mrow++;\n        mcol--;\n      }\n      mrow = --rowshift - alen + 1;\n      mcol = --colshift;\n    }\n    for (var i = 0; i < alen; i++) {\n      result += vals[i];\n    }\n    for (; i < alend; i++) {\n      result -= vals[i];\n    }\n    return result;\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(var i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (var i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b),\n    h = m.length,\n    w = m[0].length;\n    var c = 0;\n    // find max pivot\n    for (var y = 0; y < h; y++) {\n      var maxrow = y;\n      for (var y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (var y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (var x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (var y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (var y2 = 0; y2 < y; y2++) {\n        for (var x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (var x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[i][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function get_Q1(x) {\n      var size = x.length;\n      var norm_x = jStat.norm(x, 2);\n      var e1 = jStat.zeros(1, size)[0];\n      e1[0] = 1;\n      var u = jStat.add(jStat.multiply(jStat.multiply(e1, norm_x), -1), x);\n      var norm_u = jStat.norm(u, 2);\n      var v = jStat.divide(u, norm_u);\n      var Q = jStat.subtract(jStat.identity(size),\n                             jStat.multiply(jStat.outer(v, v), 2));\n      return Q;\n    }\n\n    function qr(A) {\n      var size = A[0].length;\n      var QList = [];\n      jStat.arange(size).forEach(function(i) {\n        var x = jStat.slice(A, { row: { start: i }, col: i });\n        var Q = get_Q1(x);\n        var Qn = jStat.identity(A.length);\n        Qn = jStat.sliceAssign(Qn, { row: { start: i }, col: { start: i }}, Q);\n        A = jStat.multiply(Qn, A);\n        QList.push(Qn);\n      });\n      var Q = QList.reduce(function(x, y){ return jStat.multiply(x,y) });\n      var R = A;\n      return [Q, R];\n    }\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      x = jStat.copy(x);\n      r = jStat.zeros(p, p);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function(A, b) {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n\t  var Q2 = jStat.transpose(Q1);\n\n\t  if(Q2[0].length === undefined){\n\t\t  Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n\t  if(x.length === undefined){\n\t\t  x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var count = 0;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      count++;\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (var i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (var i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (var i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I, d;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var n = X.length,\n    h_min = Math.abs(x - X[pos(X, x) + 1]),\n    i = 0,\n    g = [],\n    h1 = [],\n    y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (var i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (var i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var flag = false;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (var i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (var i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (var i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (var i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // 2 sample case\n    if (args.length === 2) {\n      return jStat.variance(args[0]) / jStat.variance(args[1]);\n    }\n    // Builds sample array\n    sample = new Array();\n    for (var i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (var i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (var i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n\n  function sub_regress(endog, exog) {\n    return ols(endog, exog);\n  }\n\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jStat/dist/jstat.js\n// module id = 21\n// module chunks = 0","var utils = require('./utils');\r\nvar error = require('./error');\r\n\r\nexports.UNIQUE = function () {\r\n  var result = [];\r\n  for (var i = 0; i < arguments.length; ++i) {\r\n    var hasElement = false;\r\n    var element    = arguments[i];\r\n\r\n    // Check if we've already seen this element.\r\n    for (var j = 0; j < result.length; ++j) {\r\n      hasElement = result[j] === element;\r\n      if (hasElement) { break; }\r\n    }\r\n\r\n    // If we did not find it, add it to the result.\r\n    if (!hasElement) {\r\n      result.push(element);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.FLATTEN = utils.flatten;\r\n\r\nexports.ARGS2ARRAY = function () {\r\n  return Array.prototype.slice.call(arguments, 0);\r\n};\r\n\r\nexports.REFERENCE = function (context, reference) {\r\n  if (!arguments.length) {\r\n    return error.error;\r\n  }\r\n  try {\r\n    var path = reference.split('.');\r\n    var result = context;\r\n    for (var i = 0; i < path.length; ++i) {\r\n      var step = path[i];\r\n      if (step[step.length - 1] === ']') {\r\n        var opening = step.indexOf('[');\r\n        var index = step.substring(opening + 1, step.length - 1);\r\n        result = result[step.substring(0, opening)][index];\r\n      } else {\r\n        result = result[step];\r\n      }\r\n    }\r\n    return result;\r\n  } catch (error) {}\r\n};\r\n\r\nexports.JOIN = function (array, separator) {\r\n  return array.join(separator);\r\n};\r\n\r\nexports.NUMBERS = function () {\r\n  var possibleNumbers = utils.flatten(arguments);\r\n  return possibleNumbers.filter(function (el) {\r\n    return typeof el === 'number';\r\n  });\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/miscellaneous.js\n// module id = 22\n// module chunks = 0","var error = require('./error');\r\n\r\n// TODO\r\nexports.CELL = function() {\r\n  throw new Error('CELL is not implemented');\r\n};\r\n\r\nexports.ERROR = {};\r\nexports.ERROR.TYPE = function(error_val) {\r\n  switch (error_val) {\r\n    case error.nil: return 1;\r\n    case error.div0: return 2;\r\n    case error.value: return 3;\r\n    case error.ref: return 4;\r\n    case error.name: return 5;\r\n    case error.num: return 6;\r\n    case error.na: return 7;\r\n    case error.data: return 8;\r\n  }\r\n  return error.na;\r\n};\r\n\r\n// TODO\r\nexports.INFO = function() {\r\n  throw new Error('INFO is not implemented');\r\n};\r\n\r\nexports.ISBLANK = function(value) {\r\n  return value === null;\r\n};\r\n\r\nexports.ISBINARY = function (number) {\r\n  return (/^[01]{1,10}$/).test(number);\r\n};\r\n\r\nexports.ISERR = function(value) {\r\n  return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||\r\n    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));\r\n};\r\n\r\nexports.ISERROR = function(value) {\r\n  return exports.ISERR(value) || value === error.na;\r\n};\r\n\r\nexports.ISEVEN = function(number) {\r\n  return (Math.floor(Math.abs(number)) & 1) ? false : true;\r\n};\r\n\r\n// TODO\r\nexports.ISFORMULA = function() {\r\n  throw new Error('ISFORMULA is not implemented');\r\n};\r\n\r\nexports.ISLOGICAL = function(value) {\r\n  return value === true || value === false;\r\n};\r\n\r\nexports.ISNA = function(value) {\r\n  return value === error.na;\r\n};\r\n\r\nexports.ISNONTEXT = function(value) {\r\n  return typeof(value) !== 'string';\r\n};\r\n\r\nexports.ISNUMBER = function(value) {\r\n  return typeof(value) === 'number' && !isNaN(value) && isFinite(value);\r\n};\r\n\r\nexports.ISODD = function(number) {\r\n  return (Math.floor(Math.abs(number)) & 1) ? true : false;\r\n};\r\n\r\n// TODO\r\nexports.ISREF = function() {\r\n  throw new Error('ISREF is not implemented');\r\n};\r\n\r\nexports.ISTEXT = function(value) {\r\n  return typeof(value) === 'string';\r\n};\r\n\r\nexports.N = function(value) {\r\n  if (this.ISNUMBER(value)) {\r\n    return value;\r\n  }\r\n  if (value instanceof Date) {\r\n    return value.getTime();\r\n  }\r\n  if (value === true) {\r\n    return 1;\r\n  }\r\n  if (value === false) {\r\n    return 0;\r\n  }\r\n  if (this.ISERROR(value)) {\r\n    return value;\r\n  }\r\n  return 0;\r\n};\r\n\r\nexports.NA = function() {\r\n  return error.na;\r\n};\r\n\r\n\r\n// TODO\r\nexports.SHEET = function() {\r\n  throw new Error('SHEET is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.SHEETS = function() {\r\n  throw new Error('SHEETS is not implemented');\r\n};\r\n\r\nexports.TYPE = function(value) {\r\n  if (this.ISNUMBER(value)) {\r\n    return 1;\r\n  }\r\n  if (this.ISTEXT(value)) {\r\n    return 2;\r\n  }\r\n  if (this.ISLOGICAL(value)) {\r\n    return 4;\r\n  }\r\n  if (this.ISERROR(value)) {\r\n    return 16;\r\n  }\r\n  if (Array.isArray(value)) {\r\n    return 64;\r\n  }\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/information.js\n// module id = 23\n// module chunks = 0","var error = require('./error');\r\nvar jStat = require('jStat').jStat;\r\nvar text = require('./text');\r\nvar utils = require('./utils');\r\nvar bessel = require('bessel');\r\n\r\nfunction isValidBinaryNumber(number) {\r\n  return (/^[01]{1,10}$/).test(number);\r\n}\r\n\r\nexports.BESSELI = function(x, n) {\r\n  x = utils.parseNumber(x);\r\n  n = utils.parseNumber(n);\r\n  if (utils.anyIsError(x, n)) {\r\n    return error.value;\r\n  }\r\n\r\n  return bessel.besseli(x, n);\r\n};\r\n\r\nexports.BESSELJ = function(x, n) {\r\n  x = utils.parseNumber(x);\r\n  n = utils.parseNumber(n);\r\n  if (utils.anyIsError(x, n)) {\r\n    return error.value;\r\n  }\r\n\r\n  return bessel.besselj(x, n);\r\n};\r\n\r\nexports.BESSELK = function(x, n) {\r\n  x = utils.parseNumber(x);\r\n  n = utils.parseNumber(n);\r\n  if (utils.anyIsError(x, n)) {\r\n    return error.value;\r\n  }\r\n\r\n  return bessel.besselk(x, n);\r\n};\r\n\r\nexports.BESSELY = function(x, n) {\r\n  x = utils.parseNumber(x);\r\n  n = utils.parseNumber(n);\r\n  if (utils.anyIsError(x, n)) {\r\n    return error.value;\r\n  }\r\n\r\n  return bessel.bessely(x, n);\r\n};\r\n\r\nexports.BIN2DEC = function(number) {\r\n  // Return error if number is not binary or contains more than 10 characters (10 digits)\r\n  if (!isValidBinaryNumber(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Convert binary number to decimal\r\n  var result = parseInt(number, 2);\r\n\r\n  // Handle negative numbers\r\n  var stringified = number.toString();\r\n  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {\r\n    return parseInt(stringified.substring(1), 2) - 512;\r\n  } else {\r\n    return result;\r\n  }\r\n};\r\n\r\n\r\nexports.BIN2HEX = function(number, places) {\r\n  // Return error if number is not binary or contains more than 10 characters (10 digits)\r\n  if (!isValidBinaryNumber(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character hexadecimal number if number is negative\r\n  var stringified = number.toString();\r\n  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {\r\n    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);\r\n  }\r\n\r\n  // Convert binary number to hexadecimal\r\n  var result = parseInt(number, 2).toString(16);\r\n\r\n  // Return hexadecimal number using the minimum number of characters necessary if places is undefined\r\n  if (places === undefined) {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.BIN2OCT = function(number, places) {\r\n  // Return error if number is not binary or contains more than 10 characters (10 digits)\r\n  if (!isValidBinaryNumber(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character octal number if number is negative\r\n  var stringified = number.toString();\r\n  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {\r\n    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);\r\n  }\r\n\r\n  // Convert binary number to octal\r\n  var result = parseInt(number, 2).toString(8);\r\n\r\n  // Return octal number using the minimum number of characters necessary if places is undefined\r\n  if (places === undefined) {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.BITAND = function(number1, number2) {\r\n  // Return error if either number is a non-numeric value\r\n  number1 = utils.parseNumber(number1);\r\n  number2 = utils.parseNumber(number2);\r\n  if (utils.anyIsError(number1, number2)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if either number is less than 0\r\n  if (number1 < 0 || number2 < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if either number is a non-integer\r\n  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if either number is greater than (2^48)-1\r\n  if (number1 > 281474976710655 || number2 > 281474976710655) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return bitwise AND of two numbers\r\n  return number1 & number2;\r\n};\r\n\r\nexports.BITLSHIFT = function(number, shift) {\r\n  number = utils.parseNumber(number);\r\n  shift = utils.parseNumber(shift);\r\n  if (utils.anyIsError(number, shift)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if number is less than 0\r\n  if (number < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if number is a non-integer\r\n  if (Math.floor(number) !== number) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if number is greater than (2^48)-1\r\n  if (number > 281474976710655) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if the absolute value of shift is greater than 53\r\n  if (Math.abs(shift) > 53) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return number shifted by shift bits to the left or to the right if shift is negative\r\n  return (shift >= 0) ? number << shift : number >> -shift;\r\n};\r\n\r\nexports.BITOR = function(number1, number2) {\r\n  number1 = utils.parseNumber(number1);\r\n  number2 = utils.parseNumber(number2);\r\n  if (utils.anyIsError(number1, number2)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if either number is less than 0\r\n  if (number1 < 0 || number2 < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if either number is a non-integer\r\n  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if either number is greater than (2^48)-1\r\n  if (number1 > 281474976710655 || number2 > 281474976710655) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return bitwise OR of two numbers\r\n  return number1 | number2;\r\n};\r\n\r\nexports.BITRSHIFT = function(number, shift) {\r\n  number = utils.parseNumber(number);\r\n  shift = utils.parseNumber(shift);\r\n  if (utils.anyIsError(number, shift)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if number is less than 0\r\n  if (number < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if number is a non-integer\r\n  if (Math.floor(number) !== number) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if number is greater than (2^48)-1\r\n  if (number > 281474976710655) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if the absolute value of shift is greater than 53\r\n  if (Math.abs(shift) > 53) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return number shifted by shift bits to the right or to the left if shift is negative\r\n  return (shift >= 0) ? number >> shift : number << -shift;\r\n};\r\n\r\nexports.BITXOR = function(number1, number2) {\r\n  number1 = utils.parseNumber(number1);\r\n  number2 = utils.parseNumber(number2);\r\n  if (utils.anyIsError(number1, number2)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if either number is less than 0\r\n  if (number1 < 0 || number2 < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if either number is a non-integer\r\n  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if either number is greater than (2^48)-1\r\n  if (number1 > 281474976710655 || number2 > 281474976710655) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return bitwise XOR of two numbers\r\n  return number1 ^ number2;\r\n};\r\n\r\nexports.COMPLEX = function(real, imaginary, suffix) {\r\n  real = utils.parseNumber(real);\r\n  imaginary = utils.parseNumber(imaginary);\r\n  if (utils.anyIsError(real, imaginary)) {\r\n    return real;\r\n  }\r\n\r\n  // Set suffix\r\n  suffix = (suffix === undefined) ? 'i' : suffix;\r\n\r\n  // Return error if suffix is neither \"i\" nor \"j\"\r\n  if (suffix !== 'i' && suffix !== 'j') {\r\n    return error.value;\r\n  }\r\n\r\n  // Return complex number\r\n  if (real === 0 && imaginary === 0) {\r\n    return 0;\r\n  } else if (real === 0) {\r\n    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;\r\n  } else if (imaginary === 0) {\r\n    return real.toString();\r\n  } else {\r\n    var sign = (imaginary > 0) ? '+' : '';\r\n    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);\r\n  }\r\n};\r\n\r\nexports.CONVERT = function(number, from_unit, to_unit) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n\r\n  // List of units supported by CONVERT and units defined by the International System of Units\r\n  // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]\r\n  var units = [\r\n    [\"a.u. of action\", \"?\", null, \"action\", false, false, 1.05457168181818e-34],\r\n    [\"a.u. of charge\", \"e\", null, \"electric_charge\", false, false, 1.60217653141414e-19],\r\n    [\"a.u. of energy\", \"Eh\", null, \"energy\", false, false, 4.35974417757576e-18],\r\n    [\"a.u. of length\", \"a?\", null, \"length\", false, false, 5.29177210818182e-11],\r\n    [\"a.u. of mass\", \"m?\", null, \"mass\", false, false, 9.10938261616162e-31],\r\n    [\"a.u. of time\", \"?/Eh\", null, \"time\", false, false, 2.41888432650516e-17],\r\n    [\"admiralty knot\", \"admkn\", null, \"speed\", false, true, 0.514773333],\r\n    [\"ampere\", \"A\", null, \"electric_current\", true, false, 1],\r\n    [\"ampere per meter\", \"A/m\", null, \"magnetic_field_intensity\", true, false, 1],\r\n    [\"ngstrm\", \"\", [\"ang\"], \"length\", false, true, 1e-10],\r\n    [\"are\", \"ar\", null, \"area\", false, true, 100],\r\n    [\"astronomical unit\", \"ua\", null, \"length\", false, false, 1.49597870691667e-11],\r\n    [\"bar\", \"bar\", null, \"pressure\", false, false, 100000],\r\n    [\"barn\", \"b\", null, \"area\", false, false, 1e-28],\r\n    [\"becquerel\", \"Bq\", null, \"radioactivity\", true, false, 1],\r\n    [\"bit\", \"bit\", [\"b\"], \"information\", false, true, 1],\r\n    [\"btu\", \"BTU\", [\"btu\"], \"energy\", false, true, 1055.05585262],\r\n    [\"byte\", \"byte\", null, \"information\", false, true, 8],\r\n    [\"candela\", \"cd\", null, \"luminous_intensity\", true, false, 1],\r\n    [\"candela per square metre\", \"cd/m?\", null, \"luminance\", true, false, 1],\r\n    [\"coulomb\", \"C\", null, \"electric_charge\", true, false, 1],\r\n    [\"cubic ngstrm\", \"ang3\", [\"ang^3\"], \"volume\", false, true, 1e-30],\r\n    [\"cubic foot\", \"ft3\", [\"ft^3\"], \"volume\", false, true, 0.028316846592],\r\n    [\"cubic inch\", \"in3\", [\"in^3\"], \"volume\", false, true, 0.000016387064],\r\n    [\"cubic light-year\", \"ly3\", [\"ly^3\"], \"volume\", false, true, 8.46786664623715e-47],\r\n    [\"cubic metre\", \"m?\", null, \"volume\", true, true, 1],\r\n    [\"cubic mile\", \"mi3\", [\"mi^3\"], \"volume\", false, true, 4168181825.44058],\r\n    [\"cubic nautical mile\", \"Nmi3\", [\"Nmi^3\"], \"volume\", false, true, 6352182208],\r\n    [\"cubic Pica\", \"Pica3\", [\"Picapt3\", \"Pica^3\", \"Picapt^3\"], \"volume\", false, true, 7.58660370370369e-8],\r\n    [\"cubic yard\", \"yd3\", [\"yd^3\"], \"volume\", false, true, 0.764554857984],\r\n    [\"cup\", \"cup\", null, \"volume\", false, true, 0.0002365882365],\r\n    [\"dalton\", \"Da\", [\"u\"], \"mass\", false, false, 1.66053886282828e-27],\r\n    [\"day\", \"d\", [\"day\"], \"time\", false, true, 86400],\r\n    [\"degree\", \"\", null, \"angle\", false, false, 0.0174532925199433],\r\n    [\"degrees Rankine\", \"Rank\", null, \"temperature\", false, true, 0.555555555555556],\r\n    [\"dyne\", \"dyn\", [\"dy\"], \"force\", false, true, 0.00001],\r\n    [\"electronvolt\", \"eV\", [\"ev\"], \"energy\", false, true, 1.60217656514141],\r\n    [\"ell\", \"ell\", null, \"length\", false, true, 1.143],\r\n    [\"erg\", \"erg\", [\"e\"], \"energy\", false, true, 1e-7],\r\n    [\"farad\", \"F\", null, \"electric_capacitance\", true, false, 1],\r\n    [\"fluid ounce\", \"oz\", null, \"volume\", false, true, 0.0000295735295625],\r\n    [\"foot\", \"ft\", null, \"length\", false, true, 0.3048],\r\n    [\"foot-pound\", \"flb\", null, \"energy\", false, true, 1.3558179483314],\r\n    [\"gal\", \"Gal\", null, \"acceleration\", false, false, 0.01],\r\n    [\"gallon\", \"gal\", null, \"volume\", false, true, 0.003785411784],\r\n    [\"gauss\", \"G\", [\"ga\"], \"magnetic_flux_density\", false, true, 1],\r\n    [\"grain\", \"grain\", null, \"mass\", false, true, 0.0000647989],\r\n    [\"gram\", \"g\", null, \"mass\", false, true, 0.001],\r\n    [\"gray\", \"Gy\", null, \"absorbed_dose\", true, false, 1],\r\n    [\"gross registered ton\", \"GRT\", [\"regton\"], \"volume\", false, true, 2.8316846592],\r\n    [\"hectare\", \"ha\", null, \"area\", false, true, 10000],\r\n    [\"henry\", \"H\", null, \"inductance\", true, false, 1],\r\n    [\"hertz\", \"Hz\", null, \"frequency\", true, false, 1],\r\n    [\"horsepower\", \"HP\", [\"h\"], \"power\", false, true, 745.69987158227],\r\n    [\"horsepower-hour\", \"HPh\", [\"hh\", \"hph\"], \"energy\", false, true, 2684519.538],\r\n    [\"hour\", \"h\", [\"hr\"], \"time\", false, true, 3600],\r\n    [\"imperial gallon (U.K.)\", \"uk_gal\", null, \"volume\", false, true, 0.00454609],\r\n    [\"imperial hundredweight\", \"lcwt\", [\"uk_cwt\", \"hweight\"], \"mass\", false, true, 50.802345],\r\n    [\"imperial quart (U.K)\", \"uk_qt\", null, \"volume\", false, true, 0.0011365225],\r\n    [\"imperial ton\", \"brton\", [\"uk_ton\", \"LTON\"], \"mass\", false, true, 1016.046909],\r\n    [\"inch\", \"in\", null, \"length\", false, true, 0.0254],\r\n    [\"international acre\", \"uk_acre\", null, \"area\", false, true, 4046.8564224],\r\n    [\"IT calorie\", \"cal\", null, \"energy\", false, true, 4.1868],\r\n    [\"joule\", \"J\", null, \"energy\", true, true, 1],\r\n    [\"katal\", \"kat\", null, \"catalytic_activity\", true, false, 1],\r\n    [\"kelvin\", \"K\", [\"kel\"], \"temperature\", true, true, 1],\r\n    [\"kilogram\", \"kg\", null, \"mass\", true, true, 1],\r\n    [\"knot\", \"kn\", null, \"speed\", false, true, 0.514444444444444],\r\n    [\"light-year\", \"ly\", null, \"length\", false, true, 9460730472580800],\r\n    [\"litre\", \"L\", [\"l\", \"lt\"], \"volume\", false, true, 0.001],\r\n    [\"lumen\", \"lm\", null, \"luminous_flux\", true, false, 1],\r\n    [\"lux\", \"lx\", null, \"illuminance\", true, false, 1],\r\n    [\"maxwell\", \"Mx\", null, \"magnetic_flux\", false, false, 1e-18],\r\n    [\"measurement ton\", \"MTON\", null, \"volume\", false, true, 1.13267386368],\r\n    [\"meter per hour\", \"m/h\", [\"m/hr\"], \"speed\", false, true, 0.00027777777777778],\r\n    [\"meter per second\", \"m/s\", [\"m/sec\"], \"speed\", true, true, 1],\r\n    [\"meter per second squared\", \"m?s??\", null, \"acceleration\", true, false, 1],\r\n    [\"parsec\", \"pc\", [\"parsec\"], \"length\", false, true, 30856775814671900],\r\n    [\"meter squared per second\", \"m?/s\", null, \"kinematic_viscosity\", true, false, 1],\r\n    [\"metre\", \"m\", null, \"length\", true, true, 1],\r\n    [\"miles per hour\", \"mph\", null, \"speed\", false, true, 0.44704],\r\n    [\"millimetre of mercury\", \"mmHg\", null, \"pressure\", false, false, 133.322],\r\n    [\"minute\", \"?\", null, \"angle\", false, false, 0.000290888208665722],\r\n    [\"minute\", \"min\", [\"mn\"], \"time\", false, true, 60],\r\n    [\"modern teaspoon\", \"tspm\", null, \"volume\", false, true, 0.000005],\r\n    [\"mole\", \"mol\", null, \"amount_of_substance\", true, false, 1],\r\n    [\"morgen\", \"Morgen\", null, \"area\", false, true, 2500],\r\n    [\"n.u. of action\", \"?\", null, \"action\", false, false, 1.05457168181818e-34],\r\n    [\"n.u. of mass\", \"m?\", null, \"mass\", false, false, 9.10938261616162e-31],\r\n    [\"n.u. of speed\", \"c?\", null, \"speed\", false, false, 299792458],\r\n    [\"n.u. of time\", \"?/(me?c??)\", null, \"time\", false, false, 1.28808866778687e-21],\r\n    [\"nautical mile\", \"M\", [\"Nmi\"], \"length\", false, true, 1852],\r\n    [\"newton\", \"N\", null, \"force\", true, true, 1],\r\n    [\"rsted\", \"Oe \", null, \"magnetic_field_intensity\", false, false, 79.5774715459477],\r\n    [\"ohm\", \"\", null, \"electric_resistance\", true, false, 1],\r\n    [\"ounce mass\", \"ozm\", null, \"mass\", false, true, 0.028349523125],\r\n    [\"pascal\", \"Pa\", null, \"pressure\", true, false, 1],\r\n    [\"pascal second\", \"Pa?s\", null, \"dynamic_viscosity\", true, false, 1],\r\n    [\"pferdestrke\", \"PS\", null, \"power\", false, true, 735.49875],\r\n    [\"phot\", \"ph\", null, \"illuminance\", false, false, 0.0001],\r\n    [\"pica (1/6 inch)\", \"pica\", null, \"length\", false, true, 0.00035277777777778],\r\n    [\"pica (1/72 inch)\", \"Pica\", [\"Picapt\"], \"length\", false, true, 0.00423333333333333],\r\n    [\"poise\", \"P\", null, \"dynamic_viscosity\", false, false, 0.1],\r\n    [\"pond\", \"pond\", null, \"force\", false, true, 0.00980665],\r\n    [\"pound force\", \"lbf\", null, \"force\", false, true, 4.4482216152605],\r\n    [\"pound mass\", \"lbm\", null, \"mass\", false, true, 0.45359237],\r\n    [\"quart\", \"qt\", null, \"volume\", false, true, 0.000946352946],\r\n    [\"radian\", \"rad\", null, \"angle\", true, false, 1],\r\n    [\"second\", \"?\", null, \"angle\", false, false, 0.00000484813681109536],\r\n    [\"second\", \"s\", [\"sec\"], \"time\", true, true, 1],\r\n    [\"short hundredweight\", \"cwt\", [\"shweight\"], \"mass\", false, true, 45.359237],\r\n    [\"siemens\", \"S\", null, \"electrical_conductance\", true, false, 1],\r\n    [\"sievert\", \"Sv\", null, \"equivalent_dose\", true, false, 1],\r\n    [\"slug\", \"sg\", null, \"mass\", false, true, 14.59390294],\r\n    [\"square ngstrm\", \"ang2\", [\"ang^2\"], \"area\", false, true, 1e-20],\r\n    [\"square foot\", \"ft2\", [\"ft^2\"], \"area\", false, true, 0.09290304],\r\n    [\"square inch\", \"in2\", [\"in^2\"], \"area\", false, true, 0.00064516],\r\n    [\"square light-year\", \"ly2\", [\"ly^2\"], \"area\", false, true, 8.95054210748189e+31],\r\n    [\"square meter\", \"m?\", null, \"area\", true, true, 1],\r\n    [\"square mile\", \"mi2\", [\"mi^2\"], \"area\", false, true, 2589988.110336],\r\n    [\"square nautical mile\", \"Nmi2\", [\"Nmi^2\"], \"area\", false, true, 3429904],\r\n    [\"square Pica\", \"Pica2\", [\"Picapt2\", \"Pica^2\", \"Picapt^2\"], \"area\", false, true, 0.00001792111111111],\r\n    [\"square yard\", \"yd2\", [\"yd^2\"], \"area\", false, true, 0.83612736],\r\n    [\"statute mile\", \"mi\", null, \"length\", false, true, 1609.344],\r\n    [\"steradian\", \"sr\", null, \"solid_angle\", true, false, 1],\r\n    [\"stilb\", \"sb\", null, \"luminance\", false, false, 0.0001],\r\n    [\"stokes\", \"St\", null, \"kinematic_viscosity\", false, false, 0.0001],\r\n    [\"stone\", \"stone\", null, \"mass\", false, true, 6.35029318],\r\n    [\"tablespoon\", \"tbs\", null, \"volume\", false, true, 0.0000147868],\r\n    [\"teaspoon\", \"tsp\", null, \"volume\", false, true, 0.00000492892],\r\n    [\"tesla\", \"T\", null, \"magnetic_flux_density\", true, true, 1],\r\n    [\"thermodynamic calorie\", \"c\", null, \"energy\", false, true, 4.184],\r\n    [\"ton\", \"ton\", null, \"mass\", false, true, 907.18474],\r\n    [\"tonne\", \"t\", null, \"mass\", false, false, 1000],\r\n    [\"U.K. pint\", \"uk_pt\", null, \"volume\", false, true, 0.00056826125],\r\n    [\"U.S. bushel\", \"bushel\", null, \"volume\", false, true, 0.03523907],\r\n    [\"U.S. oil barrel\", \"barrel\", null, \"volume\", false, true, 0.158987295],\r\n    [\"U.S. pint\", \"pt\", [\"us_pt\"], \"volume\", false, true, 0.000473176473],\r\n    [\"U.S. survey mile\", \"survey_mi\", null, \"length\", false, true, 1609.347219],\r\n    [\"U.S. survey/statute acre\", \"us_acre\", null, \"area\", false, true, 4046.87261],\r\n    [\"volt\", \"V\", null, \"voltage\", true, false, 1],\r\n    [\"watt\", \"W\", null, \"power\", true, true, 1],\r\n    [\"watt-hour\", \"Wh\", [\"wh\"], \"energy\", false, true, 3600],\r\n    [\"weber\", \"Wb\", null, \"magnetic_flux\", true, false, 1],\r\n    [\"yard\", \"yd\", null, \"length\", false, true, 0.9144],\r\n    [\"year\", \"yr\", null, \"time\", false, true, 31557600]\r\n  ];\r\n\r\n  // Binary prefixes\r\n  // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]\r\n  var binary_prefixes = {\r\n    Yi: [\"yobi\", 80, 1208925819614629174706176, \"Yi\", \"yotta\"],\r\n    Zi: [\"zebi\", 70, 1180591620717411303424, \"Zi\", \"zetta\"],\r\n    Ei: [\"exbi\", 60, 1152921504606846976, \"Ei\", \"exa\"],\r\n    Pi: [\"pebi\", 50, 1125899906842624, \"Pi\", \"peta\"],\r\n    Ti: [\"tebi\", 40, 1099511627776, \"Ti\", \"tera\"],\r\n    Gi: [\"gibi\", 30, 1073741824, \"Gi\", \"giga\"],\r\n    Mi: [\"mebi\", 20, 1048576, \"Mi\", \"mega\"],\r\n    ki: [\"kibi\", 10, 1024, \"ki\", \"kilo\"]\r\n  };\r\n\r\n  // Unit prefixes\r\n  // [Name, Multiplier, Abbreviation]\r\n  var unit_prefixes = {\r\n    Y: [\"yotta\", 1e+24, \"Y\"],\r\n    Z: [\"zetta\", 1e+21, \"Z\"],\r\n    E: [\"exa\", 1e+18, \"E\"],\r\n    P: [\"peta\", 1e+15, \"P\"],\r\n    T: [\"tera\", 1e+12, \"T\"],\r\n    G: [\"giga\", 1e+09, \"G\"],\r\n    M: [\"mega\", 1e+06, \"M\"],\r\n    k: [\"kilo\", 1e+03, \"k\"],\r\n    h: [\"hecto\", 1e+02, \"h\"],\r\n    e: [\"dekao\", 1e+01, \"e\"],\r\n    d: [\"deci\", 1e-01, \"d\"],\r\n    c: [\"centi\", 1e-02, \"c\"],\r\n    m: [\"milli\", 1e-03, \"m\"],\r\n    u: [\"micro\", 1e-06, \"u\"],\r\n    n: [\"nano\", 1e-09, \"n\"],\r\n    p: [\"pico\", 1e-12, \"p\"],\r\n    f: [\"femto\", 1e-15, \"f\"],\r\n    a: [\"atto\", 1e-18, \"a\"],\r\n    z: [\"zepto\", 1e-21, \"z\"],\r\n    y: [\"yocto\", 1e-24, \"y\"]\r\n  };\r\n\r\n  // Initialize units and multipliers\r\n  var from = null;\r\n  var to = null;\r\n  var base_from_unit = from_unit;\r\n  var base_to_unit = to_unit;\r\n  var from_multiplier = 1;\r\n  var to_multiplier = 1;\r\n  var alt;\r\n\r\n  // Lookup from and to units\r\n  for (var i = 0; i < units.length; i++) {\r\n    alt = (units[i][2] === null) ? [] : units[i][2];\r\n    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {\r\n      from = units[i];\r\n    }\r\n    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {\r\n      to = units[i];\r\n    }\r\n  }\r\n\r\n  // Lookup from prefix\r\n  if (from === null) {\r\n    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];\r\n    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];\r\n\r\n    // Handle dekao unit prefix (only unit prefix with two characters)\r\n    if (from_unit.substring(0, 2) === 'da') {\r\n      from_unit_prefix = [\"dekao\", 1e+01, \"da\"];\r\n    }\r\n\r\n    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')\r\n    if (from_binary_prefix) {\r\n      from_multiplier = from_binary_prefix[2];\r\n      base_from_unit = from_unit.substring(2);\r\n    } else if (from_unit_prefix) {\r\n      from_multiplier = from_unit_prefix[1];\r\n      base_from_unit = from_unit.substring(from_unit_prefix[2].length);\r\n    }\r\n\r\n    // Lookup from unit\r\n    for (var j = 0; j < units.length; j++) {\r\n      alt = (units[j][2] === null) ? [] : units[j][2];\r\n      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {\r\n        from = units[j];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Lookup to prefix\r\n  if (to === null) {\r\n    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];\r\n    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];\r\n\r\n    // Handle dekao unit prefix (only unit prefix with two characters)\r\n    if (to_unit.substring(0, 2) === 'da') {\r\n      to_unit_prefix = [\"dekao\", 1e+01, \"da\"];\r\n    }\r\n\r\n    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')\r\n    if (to_binary_prefix) {\r\n      to_multiplier = to_binary_prefix[2];\r\n      base_to_unit = to_unit.substring(2);\r\n    } else if (to_unit_prefix) {\r\n      to_multiplier = to_unit_prefix[1];\r\n      base_to_unit = to_unit.substring(to_unit_prefix[2].length);\r\n    }\r\n\r\n    // Lookup to unit\r\n    for (var k = 0; k < units.length; k++) {\r\n      alt = (units[k][2] === null) ? [] : units[k][2];\r\n      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {\r\n        to = units[k];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return error if a unit does not exist\r\n  if (from === null || to === null) {\r\n    return error.na;\r\n  }\r\n\r\n  // Return error if units represent different quantities\r\n  if (from[3] !== to[3]) {\r\n    return error.na;\r\n  }\r\n\r\n  // Return converted number\r\n  return number * from[6] * from_multiplier / (to[6] * to_multiplier);\r\n};\r\n\r\nexports.DEC2BIN = function(number, places) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n\r\n  // Return error if number is not decimal, is lower than -512, or is greater than 511\r\n  if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character binary number if number is negative\r\n  if (number < 0) {\r\n    return '1' + text.REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);\r\n  }\r\n\r\n  // Convert decimal number to binary\r\n  var result = parseInt(number, 10).toString(2);\r\n\r\n  // Return binary number using the minimum number of characters necessary if places is undefined\r\n  if (typeof places === 'undefined') {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.DEC2HEX = function(number, places) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n\r\n  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887\r\n  if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character hexadecimal number if number is negative\r\n  if (number < 0) {\r\n    return (1099511627776 + number).toString(16);\r\n  }\r\n\r\n  // Convert decimal number to hexadecimal\r\n  var result = parseInt(number, 10).toString(16);\r\n\r\n  // Return hexadecimal number using the minimum number of characters necessary if places is undefined\r\n  if (typeof places === 'undefined') {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.DEC2OCT = function(number, places) {\r\n  number = utils.parseNumber(number);\r\n  if (number instanceof Error) {\r\n    return number;\r\n  }\r\n\r\n  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887\r\n  if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character octal number if number is negative\r\n  if (number < 0) {\r\n    return (1073741824 + number).toString(8);\r\n  }\r\n\r\n  // Convert decimal number to octal\r\n  var result = parseInt(number, 10).toString(8);\r\n\r\n  // Return octal number using the minimum number of characters necessary if places is undefined\r\n  if (typeof places === 'undefined') {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.DELTA = function(number1, number2) {\r\n  // Set number2 to zero if undefined\r\n  number2 = (number2 === undefined) ? 0 : number2;\r\n  number1 = utils.parseNumber(number1);\r\n  number2 = utils.parseNumber(number2);\r\n  if (utils.anyIsError(number1, number2)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return delta\r\n  return (number1 === number2) ? 1 : 0;\r\n};\r\n\r\n// TODO: why is upper_bound not used ? The excel documentation has no examples with upper_bound\r\nexports.ERF = function(lower_bound, upper_bound) {\r\n  // Set number2 to zero if undefined\r\n  upper_bound = (upper_bound === undefined) ? 0 : upper_bound;\r\n\r\n  lower_bound = utils.parseNumber(lower_bound);\r\n  upper_bound = utils.parseNumber(upper_bound);\r\n  if (utils.anyIsError(lower_bound, upper_bound)) {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.erf(lower_bound);\r\n};\r\n\r\n// TODO\r\nexports.ERF.PRECISE = function() {\r\n  throw new Error('ERF.PRECISE is not implemented');\r\n};\r\n\r\nexports.ERFC = function(x) {\r\n  // Return error if x is not a number\r\n  if (isNaN(x)) {\r\n    return error.value;\r\n  }\r\n\r\n  return jStat.erfc(x);\r\n};\r\n\r\n// TODO\r\nexports.ERFC.PRECISE = function() {\r\n  throw new Error('ERFC.PRECISE is not implemented');\r\n};\r\n\r\nexports.GESTEP = function(number, step) {\r\n  step = step || 0;\r\n  number = utils.parseNumber(number);\r\n  if (utils.anyIsError(step, number)) {\r\n    return number;\r\n  }\r\n\r\n  // Return delta\r\n  return (number >= step) ? 1 : 0;\r\n};\r\n\r\nexports.HEX2BIN = function(number, places) {\r\n  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)\r\n  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Check if number is negative\r\n  var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;\r\n\r\n  // Convert hexadecimal number to decimal\r\n  var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);\r\n\r\n  // Return error if number is lower than -512 or greater than 511\r\n  if (decimal < -512 || decimal > 511) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character binary number if number is negative\r\n  if (negative) {\r\n    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);\r\n  }\r\n\r\n  // Convert decimal number to binary\r\n  var result = decimal.toString(2);\r\n\r\n  // Return binary number using the minimum number of characters necessary if places is undefined\r\n  if (places === undefined) {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.HEX2DEC = function(number) {\r\n  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)\r\n  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Convert hexadecimal number to decimal\r\n  var decimal = parseInt(number, 16);\r\n\r\n  // Return decimal number\r\n  return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;\r\n};\r\n\r\nexports.HEX2OCT = function(number, places) {\r\n  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)\r\n  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Convert hexadecimal number to decimal\r\n  var decimal = parseInt(number, 16);\r\n\r\n  // Return error if number is positive and greater than 0x1fffffff (536870911)\r\n  if (decimal > 536870911 && decimal < 1098974756864) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character octal number if number is negative\r\n  if (decimal >= 1098974756864) {\r\n    return (decimal - 1098437885952).toString(8);\r\n  }\r\n\r\n  // Convert decimal number to octal\r\n  var result = decimal.toString(8);\r\n\r\n  // Return octal number using the minimum number of characters necessary if places is undefined\r\n  if (places === undefined) {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.IMABS = function(inumber) {\r\n  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  // Return error if either coefficient is not a number\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return absolute value of complex number\r\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n};\r\n\r\nexports.IMAGINARY = function(inumber) {\r\n  if (inumber === undefined || inumber === true || inumber === false) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return 0 if inumber is equal to 0\r\n  if (inumber === 0 || inumber === '0') {\r\n    return 0;\r\n  }\r\n\r\n  // Handle special cases\r\n  if (['i', 'j'].indexOf(inumber) >= 0) {\r\n    return 1;\r\n  }\r\n\r\n  // Normalize imaginary coefficient\r\n  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');\r\n\r\n  // Lookup sign\r\n  var plus = inumber.indexOf('+');\r\n  var minus = inumber.indexOf('-');\r\n  if (plus === 0) {\r\n    plus = inumber.indexOf('+', 1);\r\n  }\r\n\r\n  if (minus === 0) {\r\n    minus = inumber.indexOf('-', 1);\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var last = inumber.substring(inumber.length - 1, inumber.length);\r\n  var unit = (last === 'i' || last === 'j');\r\n\r\n  if (plus >= 0 || minus >= 0) {\r\n    // Return error if imaginary unit is neither i nor j\r\n    if (!unit) {\r\n      return error.num;\r\n    }\r\n\r\n    // Return imaginary coefficient of complex number\r\n    if (plus >= 0) {\r\n      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?\r\n        error.num :\r\n        Number(inumber.substring(plus + 1, inumber.length - 1));\r\n    } else {\r\n      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?\r\n        error.num :\r\n        -Number(inumber.substring(minus + 1, inumber.length - 1));\r\n    }\r\n  } else {\r\n    if (unit) {\r\n      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);\r\n    } else {\r\n      return (isNaN(inumber)) ? error.num : 0;\r\n    }\r\n  }\r\n};\r\n\r\nexports.IMARGUMENT = function(inumber) {\r\n  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  // Return error if either coefficient is not a number\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if inumber is equal to zero\r\n  if (x === 0 && y === 0) {\r\n    return error.div0;\r\n  }\r\n\r\n  // Return PI/2 if x is equal to zero and y is positive\r\n  if (x === 0 && y > 0) {\r\n    return Math.PI / 2;\r\n  }\r\n\r\n  // Return -PI/2 if x is equal to zero and y is negative\r\n  if (x === 0 && y < 0) {\r\n    return -Math.PI / 2;\r\n  }\r\n\r\n  // Return zero if x is negative and y is equal to zero\r\n  if (y === 0 && x > 0) {\r\n    return 0;\r\n  }\r\n\r\n  // Return zero if x is negative and y is equal to zero\r\n  if (y === 0 && x < 0) {\r\n    return -Math.PI;\r\n  }\r\n\r\n  // Return argument of complex number\r\n  if (x > 0) {\r\n    return Math.atan(y / x);\r\n  } else if (x < 0 && y >= 0) {\r\n    return Math.atan(y / x) + Math.PI;\r\n  } else {\r\n    return Math.atan(y / x) - Math.PI;\r\n  }\r\n};\r\n\r\nexports.IMCONJUGATE = function(inumber) {\r\n  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return conjugate of complex number\r\n  return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;\r\n};\r\n\r\nexports.IMCOS = function(inumber) {\r\n  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return cosine of complex number\r\n  return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);\r\n};\r\n\r\nexports.IMCOSH = function(inumber) {\r\n  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return hyperbolic cosine of complex number\r\n  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);\r\n};\r\n\r\nexports.IMCOT = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return cotangent of complex number\r\n  return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));\r\n};\r\n\r\nexports.IMDIV = function(inumber1, inumber2) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var a = exports.IMREAL(inumber1);\r\n  var b = exports.IMAGINARY(inumber1);\r\n  var c = exports.IMREAL(inumber2);\r\n  var d = exports.IMAGINARY(inumber2);\r\n\r\n  if (utils.anyIsError(a, b, c, d)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit1 = inumber1.substring(inumber1.length - 1);\r\n  var unit2 = inumber2.substring(inumber2.length - 1);\r\n  var unit = 'i';\r\n  if (unit1 === 'j') {\r\n    unit = 'j';\r\n  } else if (unit2 === 'j') {\r\n    unit = 'j';\r\n  }\r\n\r\n  // Return error if inumber2 is null\r\n  if (c === 0 && d === 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return exponential of complex number\r\n  var den = c * c + d * d;\r\n  return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);\r\n};\r\n\r\nexports.IMEXP = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return exponential of complex number\r\n  var e = Math.exp(x);\r\n  return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);\r\n};\r\n\r\nexports.IMLN = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return exponential of complex number\r\n  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);\r\n};\r\n\r\nexports.IMLOG10 = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return exponential of complex number\r\n  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);\r\n};\r\n\r\nexports.IMLOG2 = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return exponential of complex number\r\n  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);\r\n};\r\n\r\nexports.IMPOWER = function(inumber, number) {\r\n  number = utils.parseNumber(number);\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n  if (utils.anyIsError(number, x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Calculate power of modulus\r\n  var p = Math.pow(exports.IMABS(inumber), number);\r\n\r\n  // Calculate argument\r\n  var t = exports.IMARGUMENT(inumber);\r\n\r\n  // Return exponential of complex number\r\n  return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);\r\n};\r\n\r\nexports.IMPRODUCT = function() {\r\n  // Initialize result\r\n  var result = arguments[0];\r\n\r\n  if (!arguments.length) {\r\n    return error.value;\r\n  }\r\n\r\n  // Loop on all numbers\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    // Lookup coefficients of two complex numbers\r\n    var a = exports.IMREAL(result);\r\n    var b = exports.IMAGINARY(result);\r\n    var c = exports.IMREAL(arguments[i]);\r\n    var d = exports.IMAGINARY(arguments[i]);\r\n\r\n    if (utils.anyIsError(a, b, c, d)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Complute product of two complex numbers\r\n    result = exports.COMPLEX(a * c - b * d, a * d + b * c);\r\n  }\r\n\r\n  // Return product of complex numbers\r\n  return result;\r\n};\r\n\r\nexports.IMREAL = function(inumber) {\r\n  if (inumber === undefined || inumber === true || inumber === false) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return 0 if inumber is equal to 0\r\n  if (inumber === 0 || inumber === '0') {\r\n    return 0;\r\n  }\r\n\r\n  // Handle special cases\r\n  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {\r\n    return 0;\r\n  }\r\n\r\n  // Lookup sign\r\n  var plus = inumber.indexOf('+');\r\n  var minus = inumber.indexOf('-');\r\n  if (plus === 0) {\r\n    plus = inumber.indexOf('+', 1);\r\n  }\r\n  if (minus === 0) {\r\n    minus = inumber.indexOf('-', 1);\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var last = inumber.substring(inumber.length - 1, inumber.length);\r\n  var unit = (last === 'i' || last === 'j');\r\n\r\n  if (plus >= 0 || minus >= 0) {\r\n    // Return error if imaginary unit is neither i nor j\r\n    if (!unit) {\r\n      return error.num;\r\n    }\r\n\r\n    // Return real coefficient of complex number\r\n    if (plus >= 0) {\r\n      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?\r\n        error.num :\r\n        Number(inumber.substring(0, plus));\r\n    } else {\r\n      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?\r\n        error.num :\r\n        Number(inumber.substring(0, minus));\r\n    }\r\n  } else {\r\n    if (unit) {\r\n      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;\r\n    } else {\r\n      return (isNaN(inumber)) ? error.num : inumber;\r\n    }\r\n  }\r\n};\r\n\r\nexports.IMSEC = function(inumber) {\r\n  // Return error if inumber is a logical value\r\n  if (inumber === true || inumber === false) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return secant of complex number\r\n  return exports.IMDIV('1', exports.IMCOS(inumber));\r\n};\r\n\r\nexports.IMSECH = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return hyperbolic secant of complex number\r\n  return exports.IMDIV('1', exports.IMCOSH(inumber));\r\n};\r\n\r\nexports.IMSIN = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return sine of complex number\r\n  return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);\r\n};\r\n\r\nexports.IMSINH = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Return hyperbolic sine of complex number\r\n  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);\r\n};\r\n\r\nexports.IMSQRT = function(inumber) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit = inumber.substring(inumber.length - 1);\r\n  unit = (unit === 'i' || unit === 'j') ? unit : 'i';\r\n\r\n  // Calculate power of modulus\r\n  var s = Math.sqrt(exports.IMABS(inumber));\r\n\r\n  // Calculate argument\r\n  var t = exports.IMARGUMENT(inumber);\r\n\r\n  // Return exponential of complex number\r\n  return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);\r\n};\r\n\r\nexports.IMCSC = function (inumber) {\r\n  // Return error if inumber is a logical value\r\n  if (inumber === true || inumber === false) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  // Return error if either coefficient is not a number\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return cosecant of complex number\r\n  return exports.IMDIV('1', exports.IMSIN(inumber));\r\n};\r\n\r\nexports.IMCSCH = function (inumber) {\r\n  // Return error if inumber is a logical value\r\n  if (inumber === true || inumber === false) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  // Return error if either coefficient is not a number\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return hyperbolic cosecant of complex number\r\n  return exports.IMDIV('1', exports.IMSINH(inumber));\r\n};\r\n\r\nexports.IMSUB = function(inumber1, inumber2) {\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var a = this.IMREAL(inumber1);\r\n  var b = this.IMAGINARY(inumber1);\r\n  var c = this.IMREAL(inumber2);\r\n  var d = this.IMAGINARY(inumber2);\r\n\r\n  if (utils.anyIsError(a, b, c, d)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup imaginary unit\r\n  var unit1 = inumber1.substring(inumber1.length - 1);\r\n  var unit2 = inumber2.substring(inumber2.length - 1);\r\n  var unit = 'i';\r\n  if (unit1 === 'j') {\r\n    unit = 'j';\r\n  } else if (unit2 === 'j') {\r\n    unit = 'j';\r\n  }\r\n\r\n  // Return _ of two complex numbers\r\n  return this.COMPLEX(a - c, b - d, unit);\r\n};\r\n\r\nexports.IMSUM = function() {\r\n  if (!arguments.length) {\r\n    return error.value;\r\n  }\r\n  var args = utils.flatten(arguments);\r\n\r\n  // Initialize result\r\n  var result = args[0];\r\n\r\n  // Loop on all numbers\r\n  for (var i = 1; i < args.length; i++) {\r\n    // Lookup coefficients of two complex numbers\r\n    var a = this.IMREAL(result);\r\n    var b = this.IMAGINARY(result);\r\n    var c = this.IMREAL(args[i]);\r\n    var d = this.IMAGINARY(args[i]);\r\n\r\n    if (utils.anyIsError(a, b, c, d)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Complute product of two complex numbers\r\n    result = this.COMPLEX(a + c, b + d);\r\n  }\r\n\r\n  // Return sum of complex numbers\r\n  return result;\r\n};\r\n\r\nexports.IMTAN = function(inumber) {\r\n  // Return error if inumber is a logical value\r\n  if (inumber === true || inumber === false) {\r\n    return error.value;\r\n  }\r\n\r\n  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]\r\n  var x = exports.IMREAL(inumber);\r\n  var y = exports.IMAGINARY(inumber);\r\n\r\n  if (utils.anyIsError(x, y)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return tangent of complex number\r\n  return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));\r\n};\r\n\r\nexports.OCT2BIN = function(number, places) {\r\n  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)\r\n  if (!/^[0-7]{1,10}$/.test(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Check if number is negative\r\n  var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;\r\n\r\n  // Convert octal number to decimal\r\n  var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);\r\n\r\n  // Return error if number is lower than -512 or greater than 511\r\n  if (decimal < -512 || decimal > 511) {\r\n    return error.num;\r\n  }\r\n\r\n  // Ignore places and return a 10-character binary number if number is negative\r\n  if (negative) {\r\n    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);\r\n  }\r\n\r\n  // Convert decimal number to binary\r\n  var result = decimal.toString(2);\r\n\r\n  // Return binary number using the minimum number of characters necessary if places is undefined\r\n  if (typeof places === 'undefined') {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\r\nexports.OCT2DEC = function(number) {\r\n  // Return error if number is not octal or contains more than ten characters (10 digits)\r\n  if (!/^[0-7]{1,10}$/.test(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Convert octal number to decimal\r\n  var decimal = parseInt(number, 8);\r\n\r\n  // Return decimal number\r\n  return (decimal >= 536870912) ? decimal - 1073741824 : decimal;\r\n};\r\n\r\nexports.OCT2HEX = function(number, places) {\r\n  // Return error if number is not octal or contains more than ten characters (10 digits)\r\n  if (!/^[0-7]{1,10}$/.test(number)) {\r\n    return error.num;\r\n  }\r\n\r\n  // Convert octal number to decimal\r\n  var decimal = parseInt(number, 8);\r\n\r\n  // Ignore places and return a 10-character octal number if number is negative\r\n  if (decimal >= 536870912) {\r\n    return 'ff' + (decimal + 3221225472).toString(16);\r\n  }\r\n\r\n  // Convert decimal number to hexadecimal\r\n  var result = decimal.toString(16);\r\n\r\n  // Return hexadecimal number using the minimum number of characters necessary if places is undefined\r\n  if (places === undefined) {\r\n    return result;\r\n  } else {\r\n    // Return error if places is nonnumeric\r\n    if (isNaN(places)) {\r\n      return error.value;\r\n    }\r\n\r\n    // Return error if places is negative\r\n    if (places < 0) {\r\n      return error.num;\r\n    }\r\n\r\n    // Truncate places in case it is not an integer\r\n    places = Math.floor(places);\r\n\r\n    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)\r\n    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;\r\n  }\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/engineering.js\n// module id = 24\n// module chunks = 0","var M = Math;\nfunction _horner(arr, v) { return arr.reduce(function(z,w){return v * z + w;},0); };\nfunction _bessel_iter(x, n, f0, f1, sign) {\n  if(!sign) sign = -1;\n  var tdx = 2 / x, f2;\n  if(n === 0) return f0;\n  if(n === 1) return f1;\n  for(var o = 1; o != n; ++o) {\n    f2 = f1 * o * tdx + sign * f0;\n    f0 = f1; f1 = f2;\n  }\n  return f1;\n}\nfunction _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {\n  return function bessel(x,n) {\n    if(n === 0) return bessel0(x);\n    if(n === 1) return bessel1(x);\n    if(n < 0) throw name + ': Order (' + n + ') must be nonnegative';\n    if(nonzero == 1 && x === 0) throw name + ': Undefined when x == 0';\n    if(nonzero == 2 && x <= 0) throw name + ': Undefined when x <= 0';\n    var b0 = bessel0(x), b1 = bessel1(x);\n    return _bessel_iter(x, n, b0, b1, sign);\n  };\n}\nvar besselj = (function() {\n  var b0_a1a = [57568490574.0,-13362590354.0,651619640.7,-11214424.18,77392.33017,-184.9052456].reverse();\n  var b0_a2a = [57568490411.0,1029532985.0,9494680.718,59272.64853,267.8532712,1.0].reverse();\n  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();\n  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();\n  var W = 0.636619772; // 2 / Math.PI\n\n  function bessel0(x) {\n    var a, a1, a2, y = x * x, xx = M.abs(x) - 0.785398164;\n    if(M.abs(x) < 8) {\n      a1 = _horner(b0_a1a, y);\n      a2 = _horner(b0_a2a, y);\n      a = a1/a2;\n    }\n    else {\n      y = 64 / y;\n      a1 = _horner(b0_a1b, y);\n      a2 = _horner(b0_a2b, y);\n      a = M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));\n    }\n    return a;\n  }\n  var b1_a1a = [72362614232.0,-7895059235.0,242396853.1,-2972611.439, 15704.48260, -30.16036606].reverse();\n  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();\n  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();\n  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();\n  function bessel1(x) {\n    var a, a1, a2, y = x*x, xx = M.abs(x) - 2.356194491;\n    if(Math.abs(x)< 8) {\n      a1 = x*_horner(b1_a1a, y);\n      a2 = _horner(b1_a2a, y);\n      a = a1 / a2;\n    } else {\n      y = 64 / y;\n      a1=_horner(b1_a1b, y);\n      a2=_horner(b1_a2b, y);\n      a=M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));\n      if(x < 0) a = -a;\n    }\n    return a;\n  }\n  return function besselj(x, n) {\n    n = Math.round(n);\n    if(n === 0) return bessel0(M.abs(x));\n    if(n === 1) return bessel1(M.abs(x));\n    if(n < 0) throw 'BESSELJ: Order (' + n + ') must be nonnegative';\n    if(M.abs(x) === 0) return 0;\n\n    var ret, j, tox = 2 / M.abs(x), m, jsum, sum, bjp, bj, bjm;\n    if(M.abs(x) > n) {\n      ret = _bessel_iter(x, n, bessel0(M.abs(x)), bessel1(M.abs(x)),-1);\n    } else {\n      m=2*M.floor((n+M.floor(M.sqrt(40*n)))/2);\n      jsum=0;\n      bjp=ret=sum=0.0;\n      bj=1.0;\n      for (j=m;j>0;j--) {\n        bjm=j*tox*bj-bjp;\n        bjp=bj;\n        bj=bjm;\n        if (M.abs(bj) > 1E10) {\n          bj *= 1E-10;\n          bjp *= 1E-10;\n          ret *= 1E-10;\n          sum *= 1E-10;\n        }\n        if (jsum) sum += bj;\n        jsum=!jsum;\n        if (j == n) ret=bjp;\n      }\n      sum=2.0*sum-bj;\n      ret /= sum;\n    }\n    return x < 0 && (n%2) ? -ret : ret;\n  };\n})();\nvar bessely = (function() {\n  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();\n  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();\n  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();\n  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();\n\n  var W = 0.636619772;\n  function bessel0(x) {\n    var a, a1, a2, y = x * x, xx = x - 0.785398164;\n    if(x < 8) {\n      a1 = _horner(b0_a1a, y);\n      a2 = _horner(b0_a2a, y);\n      a = a1/a2 + W * besselj(x,0) * M.log(x);\n    } else {\n      y = 64 / y;\n      a1 = _horner(b0_a1b, y);\n      a2 = _horner(b0_a2b, y);\n      a = M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);\n    }\n    return a;\n  }\n\n  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();\n  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();\n  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();\n  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();\n  function bessel1(x) {\n    var a, a1, a2, y = x*x, xx = x - 2.356194491;\n    if(x < 8) {\n      a1 = x*_horner(b1_a1a, y);\n      a2 = _horner(b1_a2a, y);\n      a = a1/a2 + W * (besselj(x,1) * M.log(x) - 1 / x);\n    } else {\n      y = 64 / y;\n      a1=_horner(b1_a1b, y);\n      a2=_horner(b1_a2b, y);\n      a=M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);\n    }\n    return a;\n  }\n\n  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);\n})();\nvar besseli = (function() {\n  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();\n  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();\n  function bessel0(x) {\n    if(x <= 3.75) return _horner(b0_a, x*x/(3.75*3.75));\n    return M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b0_b, 3.75/M.abs(x));\n  }\n\n  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();\n  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();\n  function bessel1(x) {\n    if(x < 3.75) return x * _horner(b1_a, x*x/(3.75*3.75));\n    return (x < 0 ? -1 : 1) * M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b1_b, 3.75/M.abs(x));\n  }\n\n  return function besseli(x, n) {\n    n = Math.round(n);\n    if(n === 0) return bessel0(x);\n    if(n == 1) return bessel1(x);\n    if(n < 0) throw 'BESSELI Order (' + n + ') must be nonnegative';\n    if(M.abs(x) === 0) return 0;\n\n    var ret, j, tox = 2 / M.abs(x), m, bip, bi, bim;\n    m=2*M.round((n+M.round(M.sqrt(40*n)))/2);\n    bip=ret=0.0;\n    bi=1.0;\n    for (j=m;j>0;j--) {\n      bim=j*tox*bi + bip;\n      bip=bi; bi=bim;\n      if (M.abs(bi) > 1E10) {\n        bi *= 1E-10;\n        bip *= 1E-10;\n        ret *= 1E-10;\n      }\n      if(j == n) ret = bip;\n    }\n    ret *= besseli(x, 0) / bi;\n    return x < 0 && (n%2) ? -ret : ret;\n  };\n\n})();\n\nvar besselk = (function() {\n  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();\n  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();\n  function bessel0(x) {\n    if(x <= 2) return -M.log(x/2)*besseli(x,0) + _horner(b0_a, x*x/4);\n    return M.exp(-x)/M.sqrt(x)*_horner(b0_b, 2/x);\n  }\n\n  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();\n  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();\n  function bessel1(x) {\n    if(x <= 2) return M.log(x/2)*besseli(x,1) + (1/x)*_horner(b1_a, x*x/4);\n    return M.exp(-x)/M.sqrt(x)*_horner(b1_b, 2/x);\n  }\n\n  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);\n})();\nif(typeof exports !== \"undefined\") {\n  exports.besselj = besselj;\n  exports.bessely = bessely;\n  exports.besseli = besseli;\n  exports.besselk = besselk;\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/bessel/bessel.js\n// module id = 25\n// module chunks = 0","var error = require('./error');\r\nvar utils = require('./utils');\r\n\r\nvar d1900 = new Date(Date.UTC(1900, 0, 1));\r\nvar WEEK_STARTS = [\r\n  undefined,\r\n  0,\r\n  1,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  undefined,\r\n  1,\r\n  2,\r\n  3,\r\n  4,\r\n  5,\r\n  6,\r\n  0\r\n];\r\nvar WEEK_TYPES = [\r\n  [],\r\n  [1, 2, 3, 4, 5, 6, 7],\r\n  [7, 1, 2, 3, 4, 5, 6],\r\n  [6, 0, 1, 2, 3, 4, 5],\r\n  [],\r\n  [],\r\n  [],\r\n  [],\r\n  [],\r\n  [],\r\n  [],\r\n  [7, 1, 2, 3, 4, 5, 6],\r\n  [6, 7, 1, 2, 3, 4, 5],\r\n  [5, 6, 7, 1, 2, 3, 4],\r\n  [4, 5, 6, 7, 1, 2, 3],\r\n  [3, 4, 5, 6, 7, 1, 2],\r\n  [2, 3, 4, 5, 6, 7, 1],\r\n  [1, 2, 3, 4, 5, 6, 7]\r\n];\r\nvar WEEKEND_TYPES = [\r\n  [],\r\n  [6, 0],\r\n  [0, 1],\r\n  [1, 2],\r\n  [2, 3],\r\n  [3, 4],\r\n  [4, 5],\r\n  [5, 6],\r\n  undefined,\r\n  undefined,\r\n  undefined, [0, 0],\r\n  [1, 1],\r\n  [2, 2],\r\n  [3, 3],\r\n  [4, 4],\r\n  [5, 5],\r\n  [6, 6]\r\n];\r\n\r\nexports.DATE = function(year, month, day) {\r\n  var result;\r\n\r\n  year = utils.parseNumber(year);\r\n  month = utils.parseNumber(month);\r\n  day = utils.parseNumber(day);\r\n\r\n  if (utils.anyIsError(year, month, day)) {\r\n    result = error.value;\r\n\r\n  } else if (year < 0 || month < 0 || day < 0) {\r\n    result = error.num;\r\n\r\n  } else {\r\n    result = new Date(year, month - 1, day);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexports.DATEDIF = function(start_date, end_date, interval) {\r\n  end_date = utils.parseDate(end_date);\r\n  start_date = utils.parseDate(start_date);\r\n\r\n  if (end_date instanceof Error) {\r\n    return end_date;\r\n  }\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  if (typeof interval !== 'string') {\r\n    return error.value;\r\n  }\r\n\r\n  var difference = end_date - start_date;\r\n  switch (interval.toLowerCase()) {\r\n    case 'y':\r\n      return Math.floor(difference / 31556952000);\r\n    case 'm':\r\n      return Math.floor(difference / 2629746000);\r\n    case 'd':\r\n      return Math.floor(difference / 86400000);\r\n  }\r\n};\r\n\r\nexports.DATEVALUE = function(date_text) {\r\n  var modifier = 2;\r\n  var date;\r\n\r\n  if (typeof date_text !== 'string') {\r\n    return error.value;\r\n  }\r\n\r\n  date = Date.parse(date_text);\r\n\r\n  if (isNaN(date)) {\r\n    return error.value;\r\n  }\r\n\r\n  if (date <= -2203891200000) {\r\n    modifier = 1;\r\n  }\r\n\r\n  return Math.ceil((date - d1900) / 86400000) + modifier;\r\n};\r\n\r\nexports.DAY = function(serial_number) {\r\n  var date = utils.parseDate(serial_number);\r\n  if (date instanceof Error) {\r\n    return date;\r\n  }\r\n\r\n  return date.getDate();\r\n};\r\n\r\nexports.DAYS = function(end_date, start_date) {\r\n  end_date = utils.parseDate(end_date);\r\n  start_date = utils.parseDate(start_date);\r\n\r\n  if (end_date instanceof Error) {\r\n    return end_date;\r\n  }\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n\r\n  return serial(end_date) - serial(start_date);\r\n};\r\n\r\nexports.DAYS360 = function(start_date, end_date, method) {\r\n  method = utils.parseBool(method);\r\n  start_date = utils.parseDate(start_date);\r\n  end_date = utils.parseDate(end_date);\r\n\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  if (end_date instanceof Error) {\r\n    return end_date;\r\n  }\r\n  if (method instanceof Error) {\r\n    return method;\r\n  }\r\n  var sm = start_date.getMonth();\r\n  var em = end_date.getMonth();\r\n  var sd, ed;\r\n\r\n  if (method) {\r\n    sd = start_date.getDate() === 31 ? 30 : start_date.getDate();\r\n    ed = end_date.getDate() === 31 ? 30 : end_date.getDate();\r\n  } else {\r\n    var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();\r\n    var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();\r\n    sd = start_date.getDate() === smd ? 30 : start_date.getDate();\r\n    if (end_date.getDate() === emd) {\r\n      if (sd < 30) {\r\n        em++;\r\n        ed = 1;\r\n      } else {\r\n        ed = 30;\r\n      }\r\n    } else {\r\n      ed = end_date.getDate();\r\n    }\r\n  }\r\n\r\n  return 360 * (end_date.getFullYear() - start_date.getFullYear()) +\r\n    30 * (em - sm) + (ed - sd);\r\n};\r\n\r\nexports.EDATE = function(start_date, months) {\r\n  start_date = utils.parseDate(start_date);\r\n\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  if (isNaN(months)) {\r\n    return error.value;\r\n  }\r\n  months = parseInt(months, 10);\r\n  start_date.setMonth(start_date.getMonth() + months);\r\n\r\n  return serial(start_date);\r\n};\r\n\r\nexports.EOMONTH = function(start_date, months) {\r\n  start_date = utils.parseDate(start_date);\r\n\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  if (isNaN(months)) {\r\n    return error.value;\r\n  }\r\n  months = parseInt(months, 10);\r\n\r\n  return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));\r\n};\r\n\r\nexports.HOUR = function(serial_number) {\r\n  serial_number = utils.parseDate(serial_number);\r\n\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n\r\n  return serial_number.getHours();\r\n};\r\n\r\nexports.INTERVAL = function (second) {\r\n  if (typeof second !== 'number' && typeof second !== 'string') {\r\n    return error.value;\r\n  } else {\r\n    second = parseInt(second, 10);\r\n  }\r\n\r\n  var year  = Math.floor(second/946080000);\r\n  second    = second%946080000;\r\n  var month = Math.floor(second/2592000);\r\n  second    = second%2592000;\r\n  var day   = Math.floor(second/86400);\r\n  second    = second%86400;\r\n\r\n  var hour  = Math.floor(second/3600);\r\n  second    = second%3600;\r\n  var min   = Math.floor(second/60);\r\n  second    = second%60;\r\n  var sec   = second;\r\n\r\n  year  = (year  > 0) ? year  + 'Y' : '';\r\n  month = (month > 0) ? month + 'M' : '';\r\n  day   = (day   > 0) ? day   + 'D' : '';\r\n  hour  = (hour  > 0) ? hour  + 'H' : '';\r\n  min   = (min   > 0) ? min   + 'M' : '';\r\n  sec   = (sec   > 0) ? sec   + 'S' : '';\r\n\r\n  return 'P' + year + month + day + 'T' + hour + min + sec;\r\n};\r\n\r\nexports.ISOWEEKNUM = function(date) {\r\n  date = utils.parseDate(date);\r\n\r\n  if (date instanceof Error) {\r\n    return date;\r\n  }\r\n\r\n  date.setHours(0, 0, 0);\r\n  date.setDate(date.getDate() + 4 - (date.getDay() || 7));\r\n  var yearStart = new Date(date.getFullYear(), 0, 1);\r\n\r\n  return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);\r\n};\r\n\r\nexports.MINUTE = function(serial_number) {\r\n  serial_number = utils.parseDate(serial_number);\r\n\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n\r\n  return serial_number.getMinutes();\r\n};\r\n\r\nexports.MONTH = function(serial_number) {\r\n  serial_number = utils.parseDate(serial_number);\r\n\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n\r\n  return serial_number.getMonth() + 1;\r\n};\r\n\r\nexports.NETWORKDAYS = function(start_date, end_date, holidays) {\r\n  return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);\r\n};\r\n\r\nexports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {\r\n  start_date = utils.parseDate(start_date);\r\n\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  end_date = utils.parseDate(end_date);\r\n\r\n  if (end_date instanceof Error) {\r\n    return end_date;\r\n  }\r\n  if (weekend === undefined) {\r\n    weekend = WEEKEND_TYPES[1];\r\n  } else {\r\n    weekend = WEEKEND_TYPES[weekend];\r\n  }\r\n  if (!(weekend instanceof Array)) {\r\n    return error.value;\r\n  }\r\n  if (holidays === undefined) {\r\n    holidays = [];\r\n  } else if (!(holidays instanceof Array)) {\r\n    holidays = [holidays];\r\n  }\r\n\r\n  for (var i = 0; i < holidays.length; i++) {\r\n    var h = utils.parseDate(holidays[i]);\r\n    if (h instanceof Error) {\r\n      return h;\r\n    }\r\n    holidays[i] = h;\r\n  }\r\n  var days = (end_date - start_date) / (1000 * 60 * 60 * 24) + 1;\r\n  var total = days;\r\n  var day = start_date;\r\n  for (i = 0; i < days; i++) {\r\n    var d = (new Date().getTimezoneOffset() > 0) ? day.getUTCDay() : day.getDay();\r\n    var dec = false;\r\n    if (d === weekend[0] || d === weekend[1]) {\r\n      dec = true;\r\n    }\r\n    for (var j = 0; j < holidays.length; j++) {\r\n      var holiday = holidays[j];\r\n      if (holiday.getDate() === day.getDate() &&\r\n        holiday.getMonth() === day.getMonth() &&\r\n        holiday.getFullYear() === day.getFullYear()) {\r\n        dec = true;\r\n        break;\r\n      }\r\n    }\r\n    if (dec) {\r\n      total--;\r\n    }\r\n    day.setDate(day.getDate() + 1);\r\n  }\r\n\r\n  return total;\r\n};\r\n\r\nexports.NOW = function() {\r\n  return new Date();\r\n};\r\n\r\nexports.SECOND = function(serial_number) {\r\n  serial_number = utils.parseDate(serial_number);\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n\r\n  return serial_number.getSeconds();\r\n};\r\n\r\nexports.TIME = function(hour, minute, second) {\r\n  hour = utils.parseNumber(hour);\r\n  minute = utils.parseNumber(minute);\r\n  second = utils.parseNumber(second);\r\n  if (utils.anyIsError(hour, minute, second)) {\r\n    return error.value;\r\n  }\r\n  if (hour < 0 || minute < 0 || second < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  return (3600 * hour + 60 * minute + second) / 86400;\r\n};\r\n\r\nexports.TIMEVALUE = function(time_text) {\r\n  time_text = utils.parseDate(time_text);\r\n\r\n  if (time_text instanceof Error) {\r\n    return time_text;\r\n  }\r\n\r\n  return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400;\r\n};\r\n\r\nexports.TODAY = function() {\r\n  return new Date();\r\n};\r\n\r\nexports.WEEKDAY = function(serial_number, return_type) {\r\n  serial_number = utils.parseDate(serial_number);\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n  if (return_type === undefined) {\r\n    return_type = 1;\r\n  }\r\n  var day = serial_number.getDay();\r\n\r\n  return WEEK_TYPES[return_type][day];\r\n};\r\n\r\nexports.WEEKNUM = function(serial_number, return_type) {\r\n  serial_number = utils.parseDate(serial_number);\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n  if (return_type === undefined) {\r\n    return_type = 1;\r\n  }\r\n  if (return_type === 21) {\r\n    return this.ISOWEEKNUM(serial_number);\r\n  }\r\n  var week_start = WEEK_STARTS[return_type];\r\n  var jan = new Date(serial_number.getFullYear(), 0, 1);\r\n  var inc = jan.getDay() < week_start ? 1 : 0;\r\n  jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1000;\r\n\r\n  return Math.floor(((serial_number - jan) / (1000 * 60 * 60 * 24)) / 7 + 1) + inc;\r\n};\r\n\r\nexports.WORKDAY = function(start_date, days, holidays) {\r\n  return this.WORKDAY.INTL(start_date, days, 1, holidays);\r\n};\r\n\r\nexports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {\r\n  start_date = utils.parseDate(start_date);\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  days = utils.parseNumber(days);\r\n  if (days instanceof Error) {\r\n    return days;\r\n  }\r\n  if (days < 0) {\r\n    return error.num;\r\n  }\r\n  if (weekend === undefined) {\r\n    weekend = WEEKEND_TYPES[1];\r\n  } else {\r\n    weekend = WEEKEND_TYPES[weekend];\r\n  }\r\n  if (!(weekend instanceof Array)) {\r\n    return error.value;\r\n  }\r\n  if (holidays === undefined) {\r\n    holidays = [];\r\n  } else if (!(holidays instanceof Array)) {\r\n    holidays = [holidays];\r\n  }\r\n  for (var i = 0; i < holidays.length; i++) {\r\n    var h = utils.parseDate(holidays[i]);\r\n    if (h instanceof Error) {\r\n      return h;\r\n    }\r\n    holidays[i] = h;\r\n  }\r\n  var d = 0;\r\n  while (d < days) {\r\n    start_date.setDate(start_date.getDate() + 1);\r\n    var day = start_date.getDay();\r\n    if (day === weekend[0] || day === weekend[1]) {\r\n      continue;\r\n    }\r\n    for (var j = 0; j < holidays.length; j++) {\r\n      var holiday = holidays[j];\r\n      if (holiday.getDate() === start_date.getDate() &&\r\n        holiday.getMonth() === start_date.getMonth() &&\r\n        holiday.getFullYear() === start_date.getFullYear()) {\r\n        d--;\r\n        break;\r\n      }\r\n    }\r\n    d++;\r\n  }\r\n\r\n  return start_date;\r\n};\r\n\r\nexports.YEAR = function(serial_number) {\r\n  serial_number = utils.parseDate(serial_number);\r\n\r\n  if (serial_number instanceof Error) {\r\n    return serial_number;\r\n  }\r\n\r\n  return serial_number.getFullYear();\r\n};\r\n\r\nfunction isLeapYear(year) {\r\n  return new Date(year, 1, 29).getMonth() === 1;\r\n}\r\n\r\n// TODO : Use DAYS ?\r\nfunction daysBetween(start_date, end_date) {\r\n  return Math.ceil((end_date - start_date) / 1000 / 60 / 60 / 24);\r\n}\r\n\r\nexports.YEARFRAC = function(start_date, end_date, basis) {\r\n  start_date = utils.parseDate(start_date);\r\n  if (start_date instanceof Error) {\r\n    return start_date;\r\n  }\r\n  end_date = utils.parseDate(end_date);\r\n  if (end_date instanceof Error) {\r\n    return end_date;\r\n  }\r\n\r\n  basis = basis || 0;\r\n  var sd = start_date.getDate();\r\n  var sm = start_date.getMonth() + 1;\r\n  var sy = start_date.getFullYear();\r\n  var ed = end_date.getDate();\r\n  var em = end_date.getMonth() + 1;\r\n  var ey = end_date.getFullYear();\r\n\r\n  switch (basis) {\r\n    case 0:\r\n      // US (NASD) 30/360\r\n      if (sd === 31 && ed === 31) {\r\n        sd = 30;\r\n        ed = 30;\r\n      } else if (sd === 31) {\r\n        sd = 30;\r\n      } else if (sd === 30 && ed === 31) {\r\n        ed = 30;\r\n      }\r\n      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;\r\n    case 1:\r\n      // Actual/actual\r\n      var feb29Between = function(date1, date2) {\r\n        var year1 = date1.getFullYear();\r\n        var mar1year1 = new Date(year1, 2, 1);\r\n        if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {\r\n          return true;\r\n        }\r\n        var year2 = date2.getFullYear();\r\n        var mar1year2 = new Date(year2, 2, 1);\r\n        return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);\r\n      };\r\n      var ylength = 365;\r\n      if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {\r\n        if ((sy === ey && isLeapYear(sy)) ||\r\n          feb29Between(start_date, end_date) ||\r\n          (em === 1 && ed === 29)) {\r\n          ylength = 366;\r\n        }\r\n        return daysBetween(start_date, end_date) / ylength;\r\n      }\r\n      var years = (ey - sy) + 1;\r\n      var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;\r\n      var average = days / years;\r\n      return daysBetween(start_date, end_date) / average;\r\n    case 2:\r\n      // Actual/360\r\n      return daysBetween(start_date, end_date) / 360;\r\n    case 3:\r\n      // Actual/365\r\n      return daysBetween(start_date, end_date) / 365;\r\n    case 4:\r\n      // European 30/360\r\n      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;\r\n  }\r\n};\r\n\r\nfunction serial(date) {\r\n  var addOn = (date > -2203891200000) ? 2 : 1;\r\n\r\n  return Math.ceil((date - d1900) / 86400000) + addOn;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/date-time.js\n// module id = 26\n// module chunks = 0","var error = require('./error');\r\nvar stats = require('./statistical');\r\nvar maths = require('./math-trig');\r\nvar utils = require('./utils');\r\n\r\nfunction compact(array) {\r\n  var result = [];\r\n\r\n  utils.arrayEach(array, function(value) {\r\n    if (value) {\r\n      result.push(value);\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nexports.FINDFIELD = function(database, title) {\r\n  var index = null;\r\n\r\n  utils.arrayEach(database, function(value, i) {\r\n    if (value[0] === title) {\r\n      index = i;\r\n      return false;\r\n    }\r\n  });\r\n\r\n  // Return error if the input field title is incorrect\r\n  if (index == null) {\r\n    return error.value;\r\n  }\r\n\r\n  return index;\r\n};\r\n\r\nfunction findResultIndex(database, criterias) {\r\n  var matches = {};\r\n  for (var i = 1; i < database[0].length; ++i) {\r\n    matches[i] = true;\r\n  }\r\n  var maxCriteriaLength = criterias[0].length;\r\n  for (i = 1; i < criterias.length; ++i) {\r\n    if (criterias[i].length > maxCriteriaLength) {\r\n      maxCriteriaLength = criterias[i].length;\r\n    }\r\n  }\r\n\r\n  for (var k = 1; k < database.length; ++k) {\r\n    for (var l = 1; l < database[k].length; ++l) {\r\n      var currentCriteriaResult = false;\r\n      var hasMatchingCriteria   = false;\r\n      for (var j = 0; j < criterias.length; ++j) {\r\n        var criteria = criterias[j];\r\n        if (criteria.length < maxCriteriaLength) {\r\n          continue;\r\n        }\r\n\r\n        var criteriaField = criteria[0];\r\n        if (database[k][0] !== criteriaField) {\r\n          continue;\r\n        }\r\n        hasMatchingCriteria = true;\r\n        for (var p = 1; p < criteria.length; ++p) {\r\n          currentCriteriaResult = currentCriteriaResult || eval(database[k][l] + criteria[p]);  // jshint ignore:line\r\n        }\r\n      }\r\n      if (hasMatchingCriteria) {\r\n        matches[l] = matches[l] && currentCriteriaResult;\r\n      }\r\n    }\r\n  }\r\n\r\n  var result = [];\r\n  for (var n = 0; n < database[0].length; ++n) {\r\n    if (matches[n]) {\r\n      result.push(n - 1);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Database functions\r\nexports.DAVERAGE = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n  var sum = 0;\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    sum += targetFields[value];\r\n  });\r\n\r\n  return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;\r\n};\r\n\r\nexports.DCOUNT = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n\r\n  return stats.COUNT(targetValues);\r\n};\r\n\r\nexports.DCOUNTA = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n\r\n  return stats.COUNTA(targetValues);\r\n};\r\n\r\nexports.DGET = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  // Return error if no record meets the criteria\r\n  if (resultIndexes.length === 0) {\r\n    return error.value;\r\n  }\r\n  // Returns the #NUM! error value because more than one record meets the\r\n  // criteria\r\n  if (resultIndexes.length > 1) {\r\n    return error.num;\r\n  }\r\n\r\n  return targetFields[resultIndexes[0]];\r\n};\r\n\r\nexports.DMAX = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var maxValue = targetFields[resultIndexes[0]];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    if (maxValue < targetFields[value]) {\r\n      maxValue = targetFields[value];\r\n    }\r\n  });\r\n\r\n  return maxValue;\r\n};\r\n\r\nexports.DMIN = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var minValue = targetFields[resultIndexes[0]];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    if (minValue > targetFields[value]) {\r\n      minValue = targetFields[value];\r\n    }\r\n  });\r\n\r\n  return minValue;\r\n};\r\n\r\nexports.DPRODUCT = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n  targetValues = compact(targetValues);\r\n\r\n  var result = 1;\r\n\r\n  utils.arrayEach(targetValues, function(value) {\r\n    result *= value;\r\n  });\r\n\r\n  return result;\r\n};\r\n\r\nexports.DSTDEV = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n  targetValues = compact(targetValues);\r\n\r\n  return stats.STDEV.S(targetValues);\r\n};\r\n\r\nexports.DSTDEVP = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n  targetValues = compact(targetValues);\r\n\r\n  return stats.STDEV.P(targetValues);\r\n};\r\n\r\nexports.DSUM = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n\r\n  return maths.SUM(targetValues);\r\n};\r\n\r\nexports.DVAR = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n\r\n  return stats.VAR.S(targetValues);\r\n};\r\n\r\nexports.DVARP = function(database, field, criteria) {\r\n  // Return error if field is not a number and not a string\r\n  if (isNaN(field) && (typeof field !== \"string\")) {\r\n    return error.value;\r\n  }\r\n  var resultIndexes = findResultIndex(database, criteria);\r\n  var targetFields = [];\r\n\r\n  if (typeof field === \"string\") {\r\n    var index = exports.FINDFIELD(database, field);\r\n    targetFields = utils.rest(database[index]);\r\n  } else {\r\n    targetFields = utils.rest(database[field]);\r\n  }\r\n  var targetValues = [];\r\n\r\n  utils.arrayEach(resultIndexes, function(value) {\r\n    targetValues.push(targetFields[value]);\r\n  });\r\n\r\n  return stats.VAR.P(targetValues);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/database.js\n// module id = 27\n// module chunks = 0","var error = require('./error');\r\nvar utils = require('./utils');\r\nvar information = require('./information');\r\n\r\nexports.AND = function() {\r\n  var args = utils.flatten(arguments);\r\n  var result = true;\r\n  for (var i = 0; i < args.length; i++) {\r\n    if (!args[i]) {\r\n      result = false;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.CHOOSE = function() {\r\n  if (arguments.length < 2) {\r\n    return error.na;\r\n  }\r\n\r\n  var index = arguments[0];\r\n  if (index < 1 || index > 254) {\r\n    return error.value;\r\n  }\r\n\r\n  if (arguments.length < index + 1) {\r\n    return error.value;\r\n  }\r\n\r\n  return arguments[index];\r\n};\r\n\r\nexports.FALSE = function() {\r\n  return false;\r\n};\r\n\r\nexports.IF = function(test, then_value, otherwise_value) {\r\n  return test ? then_value : otherwise_value;\r\n};\r\n\r\nexports.IFERROR = function(value, valueIfError) {\r\n  if (information.ISERROR(value)) {\r\n    return valueIfError;\r\n  }\r\n  return value;\r\n};\r\n\r\nexports.IFNA = function(value, value_if_na) {\r\n  return value === error.na ? value_if_na : value;\r\n};\r\n\r\nexports.NOT = function(logical) {\r\n  return !logical;\r\n};\r\n\r\nexports.OR = function() {\r\n  var args = utils.flatten(arguments);\r\n  var result = false;\r\n  for (var i = 0; i < args.length; i++) {\r\n    if (args[i]) {\r\n      result = true;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexports.TRUE = function() {\r\n  return true;\r\n};\r\n\r\nexports.XOR = function() {\r\n  var args = utils.flatten(arguments);\r\n  var result = 0;\r\n  for (var i = 0; i < args.length; i++) {\r\n    if (args[i]) {\r\n      result++;\r\n    }\r\n  }\r\n  return (Math.floor(Math.abs(result)) & 1) ? true : false;\r\n};\r\n\r\nexports.SWITCH = function () {\r\n  var result;\r\n\r\n  if (arguments.length > 0)  {\r\n    var targetValue = arguments[0];\r\n    var argc = arguments.length - 1;\r\n    var switchCount = Math.floor(argc / 2);\r\n    var switchSatisfied = false;\r\n    var hasDefaultClause = argc % 2 !== 0;\r\n    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];\r\n\r\n    if (switchCount) {\r\n      for (var index = 0; index < switchCount; index++) {\r\n        if (targetValue === arguments[index * 2 + 1]) {\r\n          result = arguments[index * 2 + 2];\r\n          switchSatisfied = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!switchSatisfied) {\r\n      result = hasDefaultClause ? defaultClause : error.na;\r\n    }\r\n  } else {\r\n    result = error.value;\r\n  }\r\n\r\n  return result;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/logical.js\n// module id = 28\n// module chunks = 0","var error = require('./error');\r\nvar dateTime = require('./date-time');\r\nvar utils = require('./utils');\r\n\r\nfunction validDate(d) {\r\n  return d && d.getTime && !isNaN(d.getTime());\r\n}\r\n\r\nfunction ensureDate(d) {\r\n  return (d instanceof Date)?d:new Date(d);\r\n}\r\n\r\nexports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {\r\n  // Return error if either date is invalid\r\n  issue      = ensureDate(issue);\r\n  first      = ensureDate(first);\r\n  settlement = ensureDate(settlement);\r\n  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if either rate or par are lower than or equal to zero\r\n  if (rate <= 0 || par <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if frequency is neither 1, 2, or 4\r\n  if ([1, 2, 4].indexOf(frequency) === -1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if basis is neither 0, 1, 2, 3, or 4\r\n  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if settlement is before or equal to issue\r\n  if (settlement <= issue) {\r\n    return error.num;\r\n  }\r\n\r\n  // Set default values\r\n  par   = par   || 0;\r\n  basis = basis || 0;\r\n\r\n  // Compute accrued interest\r\n  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);\r\n};\r\n\r\n// TODO\r\nexports.ACCRINTM = function() {\r\n  throw new Error('ACCRINTM is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.AMORDEGRC = function() {\r\n  throw new Error('AMORDEGRC is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.AMORLINC = function() {\r\n  throw new Error('AMORLINC is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.COUPDAYBS = function() {\r\n  throw new Error('COUPDAYBS is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.COUPDAYS = function() {\r\n  throw new Error('COUPDAYS is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.COUPDAYSNC = function() {\r\n  throw new Error('COUPDAYSNC is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.COUPNCD = function() {\r\n  throw new Error('COUPNCD is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.COUPNUM = function() {\r\n  throw new Error('COUPNUM is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.COUPPCD = function() {\r\n  throw new Error('COUPPCD is not implemented');\r\n};\r\n\r\nexports.CUMIPMT = function(rate, periods, value, start, end, type) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n  // Credits: Hannes Stiebitzhofer for the translations of function and variable names\r\n  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]\r\n\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  value = utils.parseNumber(value);\r\n  if (utils.anyIsError(rate, periods, value)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if either rate, periods, or value are lower than or equal to zero\r\n  if (rate <= 0 || periods <= 0 || value <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if start < 1, end < 1, or start > end\r\n  if (start < 1 || end < 1 || start > end) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if type is neither 0 nor 1\r\n  if (type !== 0 && type !== 1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Compute cumulative interest\r\n  var payment = exports.PMT(rate, periods, value, 0, type);\r\n  var interest = 0;\r\n\r\n  if (start === 1) {\r\n    if (type === 0) {\r\n      interest = -value;\r\n      start++;\r\n    }\r\n  }\r\n\r\n  for (var i = start; i <= end; i++) {\r\n    if (type === 1) {\r\n      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;\r\n    } else {\r\n      interest += exports.FV(rate, i - 1, payment, value, 0);\r\n    }\r\n  }\r\n  interest *= rate;\r\n\r\n  // Return cumulative interest\r\n  return interest;\r\n};\r\n\r\nexports.CUMPRINC = function(rate, periods, value, start, end, type) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n  // Credits: Hannes Stiebitzhofer for the translations of function and variable names\r\n\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  value = utils.parseNumber(value);\r\n  if (utils.anyIsError(rate, periods, value)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if either rate, periods, or value are lower than or equal to zero\r\n  if (rate <= 0 || periods <= 0 || value <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if start < 1, end < 1, or start > end\r\n  if (start < 1 || end < 1 || start > end) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if type is neither 0 nor 1\r\n  if (type !== 0 && type !== 1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Compute cumulative principal\r\n  var payment = exports.PMT(rate, periods, value, 0, type);\r\n  var principal = 0;\r\n  if (start === 1) {\r\n    if (type === 0) {\r\n      principal = payment + value * rate;\r\n    } else {\r\n      principal = payment;\r\n    }\r\n    start++;\r\n  }\r\n  for (var i = start; i <= end; i++) {\r\n    if (type > 0) {\r\n      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;\r\n    } else {\r\n      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;\r\n    }\r\n  }\r\n\r\n  // Return cumulative principal\r\n  return principal;\r\n};\r\n\r\nexports.DB = function(cost, salvage, life, period, month) {\r\n  // Initialize month\r\n  month = (month === undefined) ? 12 : month;\r\n\r\n  cost = utils.parseNumber(cost);\r\n  salvage = utils.parseNumber(salvage);\r\n  life = utils.parseNumber(life);\r\n  period = utils.parseNumber(period);\r\n  month = utils.parseNumber(month);\r\n  if (utils.anyIsError(cost, salvage, life, period, month)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if any of the parameters is negative\r\n  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if month is not an integer between 1 and 12\r\n  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if period is greater than life\r\n  if (period > life) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return 0 (zero) if salvage is greater than or equal to cost\r\n  if (salvage >= cost) {\r\n    return 0;\r\n  }\r\n\r\n  // Rate is rounded to three decimals places\r\n  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);\r\n\r\n  // Compute initial depreciation\r\n  var initial = cost * rate * month / 12;\r\n\r\n  // Compute total depreciation\r\n  var total = initial;\r\n  var current = 0;\r\n  var ceiling = (period === life) ? life - 1 : period;\r\n  for (var i = 2; i <= ceiling; i++) {\r\n    current = (cost - total) * rate;\r\n    total += current;\r\n  }\r\n\r\n  // Depreciation for the first and last periods are special cases\r\n  if (period === 1) {\r\n    // First period\r\n    return initial;\r\n  } else if (period === life) {\r\n    // Last period\r\n    return (cost - total) * rate;\r\n  } else {\r\n    return current;\r\n  }\r\n};\r\n\r\nexports.DDB = function(cost, salvage, life, period, factor) {\r\n  // Initialize factor\r\n  factor = (factor === undefined) ? 2 : factor;\r\n\r\n  cost = utils.parseNumber(cost);\r\n  salvage = utils.parseNumber(salvage);\r\n  life = utils.parseNumber(life);\r\n  period = utils.parseNumber(period);\r\n  factor = utils.parseNumber(factor);\r\n  if (utils.anyIsError(cost, salvage, life, period, factor)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if any of the parameters is negative or if factor is null\r\n  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if period is greater than life\r\n  if (period > life) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return 0 (zero) if salvage is greater than or equal to cost\r\n  if (salvage >= cost) {\r\n    return 0;\r\n  }\r\n\r\n  // Compute depreciation\r\n  var total = 0;\r\n  var current = 0;\r\n  for (var i = 1; i <= period; i++) {\r\n    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));\r\n    total += current;\r\n  }\r\n\r\n  // Return depreciation\r\n  return current;\r\n};\r\n\r\n// TODO\r\nexports.DISC = function() {\r\n  throw new Error('DISC is not implemented');\r\n};\r\n\r\nexports.DOLLARDE = function(dollar, fraction) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n\r\n  dollar = utils.parseNumber(dollar);\r\n  fraction = utils.parseNumber(fraction);\r\n  if (utils.anyIsError(dollar, fraction)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if fraction is negative\r\n  if (fraction < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if fraction is greater than or equal to 0 and less than 1\r\n  if (fraction >= 0 && fraction < 1) {\r\n    return error.div0;\r\n  }\r\n\r\n  // Truncate fraction if it is not an integer\r\n  fraction = parseInt(fraction, 10);\r\n\r\n  // Compute integer part\r\n  var result = parseInt(dollar, 10);\r\n\r\n  // Add decimal part\r\n  result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;\r\n\r\n  // Round result\r\n  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);\r\n  result = Math.round(result * power) / power;\r\n\r\n  // Return converted dollar price\r\n  return result;\r\n};\r\n\r\nexports.DOLLARFR = function(dollar, fraction) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n\r\n  dollar = utils.parseNumber(dollar);\r\n  fraction = utils.parseNumber(fraction);\r\n  if (utils.anyIsError(dollar, fraction)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if fraction is negative\r\n  if (fraction < 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if fraction is greater than or equal to 0 and less than 1\r\n  if (fraction >= 0 && fraction < 1) {\r\n    return error.div0;\r\n  }\r\n\r\n  // Truncate fraction if it is not an integer\r\n  fraction = parseInt(fraction, 10);\r\n\r\n  // Compute integer part\r\n  var result = parseInt(dollar, 10);\r\n\r\n  // Add decimal part\r\n  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;\r\n\r\n  // Return converted dollar price\r\n  return result;\r\n};\r\n\r\n// TODO\r\nexports.DURATION = function() {\r\n  throw new Error('DURATION is not implemented');\r\n};\r\n\r\nexports.EFFECT = function(rate, periods) {\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  if (utils.anyIsError(rate, periods)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if rate <=0 or periods < 1\r\n  if (rate <= 0 || periods < 1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Truncate periods if it is not an integer\r\n  periods = parseInt(periods, 10);\r\n\r\n  // Return effective annual interest rate\r\n  return Math.pow(1 + rate / periods, periods) - 1;\r\n};\r\n\r\nexports.FV = function(rate, periods, payment, value, type) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n\r\n  value = value || 0;\r\n  type = type || 0;\r\n\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  payment = utils.parseNumber(payment);\r\n  value = utils.parseNumber(value);\r\n  type = utils.parseNumber(type);\r\n  if (utils.anyIsError(rate, periods, payment, value, type)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return future value\r\n  var result;\r\n  if (rate === 0) {\r\n    result = value + payment * periods;\r\n  } else {\r\n    var term = Math.pow(1 + rate, periods);\r\n    if (type === 1) {\r\n      result = value * term + payment * (1 + rate) * (term - 1) / rate;\r\n    } else {\r\n      result = value * term + payment * (term - 1) / rate;\r\n    }\r\n  }\r\n  return -result;\r\n};\r\n\r\nexports.FVSCHEDULE = function(principal, schedule) {\r\n  principal = utils.parseNumber(principal);\r\n  schedule = utils.parseNumberArray(utils.flatten(schedule));\r\n  if (utils.anyIsError(principal, schedule)) {\r\n    return error.value;\r\n  }\r\n\r\n  var n = schedule.length;\r\n  var future = principal;\r\n\r\n  // Apply all interests in schedule\r\n  for (var i = 0; i < n; i++) {\r\n    // Apply scheduled interest\r\n    future *= 1 + schedule[i];\r\n  }\r\n\r\n  // Return future value\r\n  return future;\r\n};\r\n\r\n// TODO\r\nexports.INTRATE = function() {\r\n  throw new Error('INTRATE is not implemented');\r\n};\r\n\r\nexports.IPMT = function(rate, period, periods, present, future, type) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n\r\n  future = future || 0;\r\n  type = type || 0;\r\n\r\n  rate = utils.parseNumber(rate);\r\n  period = utils.parseNumber(period);\r\n  periods = utils.parseNumber(periods);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  type = utils.parseNumber(type);\r\n  if (utils.anyIsError(rate, period, periods, present, future, type)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Compute payment\r\n  var payment = exports.PMT(rate, periods, present, future, type);\r\n\r\n  // Compute interest\r\n  var interest;\r\n  if (period === 1) {\r\n    if (type === 1) {\r\n      interest = 0;\r\n    } else {\r\n      interest = -present;\r\n    }\r\n  } else {\r\n    if (type === 1) {\r\n      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;\r\n    } else {\r\n      interest = exports.FV(rate, period - 1, payment, present, 0);\r\n    }\r\n  }\r\n\r\n  // Return interest\r\n  return interest * rate;\r\n};\r\n\r\nexports.IRR = function(values, guess) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n\r\n  guess = guess || 0;\r\n\r\n  values = utils.parseNumberArray(utils.flatten(values));\r\n  guess = utils.parseNumber(guess);\r\n  if (utils.anyIsError(values, guess)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Calculates the resulting amount\r\n  var irrResult = function(values, dates, rate) {\r\n    var r = rate + 1;\r\n    var result = values[0];\r\n    for (var i = 1; i < values.length; i++) {\r\n      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);\r\n    }\r\n    return result;\r\n  };\r\n\r\n  // Calculates the first derivation\r\n  var irrResultDeriv = function(values, dates, rate) {\r\n    var r = rate + 1;\r\n    var result = 0;\r\n    for (var i = 1; i < values.length; i++) {\r\n      var frac = (dates[i] - dates[0]) / 365;\r\n      result -= frac * values[i] / Math.pow(r, frac + 1);\r\n    }\r\n    return result;\r\n  };\r\n\r\n  // Initialize dates and check that values contains at least one positive value and one negative value\r\n  var dates = [];\r\n  var positive = false;\r\n  var negative = false;\r\n  for (var i = 0; i < values.length; i++) {\r\n    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;\r\n    if (values[i] > 0) {\r\n      positive = true;\r\n    }\r\n    if (values[i] < 0) {\r\n      negative = true;\r\n    }\r\n  }\r\n\r\n  // Return error if values does not contain at least one positive value and one negative value\r\n  if (!positive || !negative) {\r\n    return error.num;\r\n  }\r\n\r\n  // Initialize guess and resultRate\r\n  guess = (guess === undefined) ? 0.1 : guess;\r\n  var resultRate = guess;\r\n\r\n  // Set maximum epsilon for end of iteration\r\n  var epsMax = 1e-10;\r\n\r\n  // Implement Newton's method\r\n  var newRate, epsRate, resultValue;\r\n  var contLoop = true;\r\n  do {\r\n    resultValue = irrResult(values, dates, resultRate);\r\n    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);\r\n    epsRate = Math.abs(newRate - resultRate);\r\n    resultRate = newRate;\r\n    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);\r\n  } while (contLoop);\r\n\r\n  // Return internal rate of return\r\n  return resultRate;\r\n};\r\n\r\nexports.ISPMT = function(rate, period, periods, value) {\r\n  rate = utils.parseNumber(rate);\r\n  period = utils.parseNumber(period);\r\n  periods = utils.parseNumber(periods);\r\n  value = utils.parseNumber(value);\r\n  if (utils.anyIsError(rate, period, periods, value)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return interest\r\n  return value * rate * (period / periods - 1);\r\n};\r\n\r\n// TODO\r\nexports.MDURATION = function() {\r\n  throw new Error('MDURATION is not implemented');\r\n};\r\n\r\nexports.MIRR = function(values, finance_rate, reinvest_rate) {\r\n  values = utils.parseNumberArray(utils.flatten(values));\r\n  finance_rate = utils.parseNumber(finance_rate);\r\n  reinvest_rate = utils.parseNumber(reinvest_rate);\r\n  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Initialize number of values\r\n  var n = values.length;\r\n\r\n  // Lookup payments (negative values) and incomes (positive values)\r\n  var payments = [];\r\n  var incomes = [];\r\n  for (var i = 0; i < n; i++) {\r\n    if (values[i] < 0) {\r\n      payments.push(values[i]);\r\n    } else {\r\n      incomes.push(values[i]);\r\n    }\r\n  }\r\n\r\n  // Return modified internal rate of return\r\n  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);\r\n  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);\r\n  return Math.pow(num / den, 1 / (n - 1)) - 1;\r\n};\r\n\r\nexports.NOMINAL = function(rate, periods) {\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  if (utils.anyIsError(rate, periods)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if rate <=0 or periods < 1\r\n  if (rate <= 0 || periods < 1) {\r\n    return error.num;\r\n  }\r\n\r\n  // Truncate periods if it is not an integer\r\n  periods = parseInt(periods, 10);\r\n\r\n  // Return nominal annual interest rate\r\n  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;\r\n};\r\n\r\nexports.NPER = function(rate, payment, present, future, type) {\r\n  type = (type === undefined) ? 0 : type;\r\n  future = (future === undefined) ? 0 : future;\r\n\r\n  rate = utils.parseNumber(rate);\r\n  payment = utils.parseNumber(payment);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  type = utils.parseNumber(type);\r\n  if (utils.anyIsError(rate, payment, present, future, type)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return number of periods\r\n  var num = payment * (1 + rate * type) - future * rate;\r\n  var den = (present * rate + payment * (1 + rate * type));\r\n  return Math.log(num / den) / Math.log(1 + rate);\r\n};\r\n\r\nexports.NPV = function() {\r\n  var args = utils.parseNumberArray(utils.flatten(arguments));\r\n  if (args instanceof Error) {\r\n    return args;\r\n  }\r\n\r\n  // Lookup rate\r\n  var rate = args[0];\r\n\r\n  // Initialize net present value\r\n  var value = 0;\r\n\r\n  // Loop on all values\r\n  for (var j = 1; j < args.length; j++) {\r\n    value += args[j] / Math.pow(1 + rate, j);\r\n  }\r\n\r\n  // Return net present value\r\n  return value;\r\n};\r\n\r\n// TODO\r\nexports.ODDFPRICE = function() {\r\n  throw new Error('ODDFPRICE is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.ODDFYIELD = function() {\r\n  throw new Error('ODDFYIELD is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.ODDLPRICE = function() {\r\n  throw new Error('ODDLPRICE is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.ODDLYIELD = function() {\r\n  throw new Error('ODDLYIELD is not implemented');\r\n};\r\n\r\nexports.PDURATION = function(rate, present, future) {\r\n  rate = utils.parseNumber(rate);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  if (utils.anyIsError(rate, present, future)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if rate <=0\r\n  if (rate <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return number of periods\r\n  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);\r\n};\r\n\r\nexports.PMT = function(rate, periods, present, future, type) {\r\n  // Credits: algorithm inspired by Apache OpenOffice\r\n  if (present === undefined) {\r\n    return 0;\r\n  }\r\n\r\n  future = future || 0;\r\n  type = type || 0;\r\n\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  type = utils.parseNumber(type);\r\n  if (utils.anyIsError(rate, periods, present, future, type)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return payment\r\n  var result;\r\n  if (rate === 0) {\r\n    result = (present + future) / periods;\r\n  } else {\r\n    var term = Math.pow(1 + rate, periods);\r\n    if (type === 1) {\r\n      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);\r\n    } else {\r\n      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);\r\n    }\r\n  }\r\n  return -result;\r\n};\r\n\r\nexports.PPMT = function(rate, period, periods, present, future, type) {\r\n  future = future || 0;\r\n  type = type || 0;\r\n\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  type = utils.parseNumber(type);\r\n  if (utils.anyIsError(rate, periods, present, future, type)) {\r\n    return error.value;\r\n  }\r\n\r\n  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);\r\n};\r\n\r\n// TODO\r\nexports.PRICE = function() {\r\n  throw new Error('PRICE is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.PRICEDISC = function() {\r\n  throw new Error('PRICEDISC is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.PRICEMAT = function() {\r\n  throw new Error('PRICEMAT is not implemented');\r\n};\r\n\r\nexports.PV = function(rate, periods, payment, future, type) {\r\n  future = future || 0;\r\n  type = type || 0;\r\n\r\n  rate = utils.parseNumber(rate);\r\n  periods = utils.parseNumber(periods);\r\n  payment = utils.parseNumber(payment);\r\n  future = utils.parseNumber(future);\r\n  type = utils.parseNumber(type);\r\n  if (utils.anyIsError(rate, periods, payment, future, type)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return present value\r\n  if (rate === 0) {\r\n    return -payment * periods - future;\r\n  } else {\r\n    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);\r\n  }\r\n};\r\n\r\nexports.RATE = function(periods, payment, present, future, type, guess) {\r\n  // Credits: rabugento\r\n\r\n  guess = (guess === undefined) ? 0.01 : guess;\r\n  future = (future === undefined) ? 0 : future;\r\n  type = (type === undefined) ? 0 : type;\r\n\r\n  periods = utils.parseNumber(periods);\r\n  payment = utils.parseNumber(payment);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  type = utils.parseNumber(type);\r\n  guess = utils.parseNumber(guess);\r\n  if (utils.anyIsError(periods, payment, present, future, type, guess)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Set maximum epsilon for end of iteration\r\n  var epsMax = 1e-10;\r\n\r\n  // Set maximum number of iterations\r\n  var iterMax = 50;\r\n\r\n  // Implement Newton's method\r\n  var y, y0, y1, x0, x1 = 0,\r\n    f = 0,\r\n    i = 0;\r\n  var rate = guess;\r\n  if (Math.abs(rate) < epsMax) {\r\n    y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\r\n  } else {\r\n    f = Math.exp(periods * Math.log(1 + rate));\r\n    y = present * f + payment * (1 / rate + type) * (f - 1) + future;\r\n  }\r\n  y0 = present + payment * periods + future;\r\n  y1 = present * f + payment * (1 / rate + type) * (f - 1) + future;\r\n  i = x0 = 0;\r\n  x1 = rate;\r\n  while ((Math.abs(y0 - y1) > epsMax) && (i < iterMax)) {\r\n    rate = (y1 * x0 - y0 * x1) / (y1 - y0);\r\n    x0 = x1;\r\n    x1 = rate;\r\n    if (Math.abs(rate) < epsMax) {\r\n      y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\r\n    } else {\r\n      f = Math.exp(periods * Math.log(1 + rate));\r\n      y = present * f + payment * (1 / rate + type) * (f - 1) + future;\r\n    }\r\n    y0 = y1;\r\n    y1 = y;\r\n    ++i;\r\n  }\r\n  return rate;\r\n};\r\n\r\n// TODO\r\nexports.RECEIVED = function() {\r\n  throw new Error('RECEIVED is not implemented');\r\n};\r\n\r\nexports.RRI = function(periods, present, future) {\r\n  periods = utils.parseNumber(periods);\r\n  present = utils.parseNumber(present);\r\n  future = utils.parseNumber(future);\r\n  if (utils.anyIsError(periods, present, future)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if periods or present is equal to 0 (zero)\r\n  if (periods === 0 || present === 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return equivalent interest rate\r\n  return Math.pow(future / present, 1 / periods) - 1;\r\n};\r\n\r\nexports.SLN = function(cost, salvage, life) {\r\n  cost = utils.parseNumber(cost);\r\n  salvage = utils.parseNumber(salvage);\r\n  life = utils.parseNumber(life);\r\n  if (utils.anyIsError(cost, salvage, life)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if life equal to 0 (zero)\r\n  if (life === 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return straight-line depreciation\r\n  return (cost - salvage) / life;\r\n};\r\n\r\nexports.SYD = function(cost, salvage, life, period) {\r\n  // Return error if any of the parameters is not a number\r\n  cost = utils.parseNumber(cost);\r\n  salvage = utils.parseNumber(salvage);\r\n  life = utils.parseNumber(life);\r\n  period = utils.parseNumber(period);\r\n  if (utils.anyIsError(cost, salvage, life, period)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if life equal to 0 (zero)\r\n  if (life === 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if period is lower than 1 or greater than life\r\n  if (period < 1 || period > life) {\r\n    return error.num;\r\n  }\r\n\r\n  // Truncate period if it is not an integer\r\n  period = parseInt(period, 10);\r\n\r\n  // Return straight-line depreciation\r\n  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));\r\n};\r\n\r\nexports.TBILLEQ = function(settlement, maturity, discount) {\r\n  settlement = utils.parseDate(settlement);\r\n  maturity = utils.parseDate(maturity);\r\n  discount = utils.parseNumber(discount);\r\n  if (utils.anyIsError(settlement, maturity, discount)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if discount is lower than or equal to zero\r\n  if (discount <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if settlement is greater than maturity\r\n  if (settlement > maturity) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if maturity is more than one year after settlement\r\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return bond-equivalent yield\r\n  return (365 * discount) / (360 - discount * dateTime.DAYS360(settlement, maturity, false));\r\n};\r\n\r\nexports.TBILLPRICE = function(settlement, maturity, discount) {\r\n  settlement = utils.parseDate(settlement);\r\n  maturity = utils.parseDate(maturity);\r\n  discount = utils.parseNumber(discount);\r\n  if (utils.anyIsError(settlement, maturity, discount)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if discount is lower than or equal to zero\r\n  if (discount <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if settlement is greater than maturity\r\n  if (settlement > maturity) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if maturity is more than one year after settlement\r\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return bond-equivalent yield\r\n  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);\r\n};\r\n\r\nexports.TBILLYIELD = function(settlement, maturity, price) {\r\n  settlement = utils.parseDate(settlement);\r\n  maturity = utils.parseDate(maturity);\r\n  price = utils.parseNumber(price);\r\n  if (utils.anyIsError(settlement, maturity, price)) {\r\n    return error.value;\r\n  }\r\n\r\n  // Return error if price is lower than or equal to zero\r\n  if (price <= 0) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if settlement is greater than maturity\r\n  if (settlement > maturity) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return error if maturity is more than one year after settlement\r\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\r\n    return error.num;\r\n  }\r\n\r\n  // Return bond-equivalent yield\r\n  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));\r\n};\r\n\r\n// TODO\r\nexports.VDB = function() {\r\n  throw new Error('VDB is not implemented');\r\n};\r\n\r\n// TODO needs better support for date\r\n// exports.XIRR = function(values, dates, guess) {\r\n//   // Credits: algorithm inspired by Apache OpenOffice\r\n//\r\n//   values = utils.parseNumberArray(utils.flatten(values));\r\n//   dates = utils.parseDateArray(utils.flatten(dates));\r\n//   guess = utils.parseNumber(guess);\r\n//\r\n//   if (utils.anyIsError(values, dates, guess)) {\r\n//     return error.value;\r\n//   }\r\n//\r\n//   // Calculates the resulting amount\r\n//   var irrResult = function(values, dates, rate) {\r\n//     var r = rate + 1;\r\n//     var result = values[0];\r\n//     for (var i = 1; i < values.length; i++) {\r\n//       result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);\r\n//     }\r\n//     return result;\r\n//   };\r\n//\r\n//   // Calculates the first derivation\r\n//   var irrResultDeriv = function(values, dates, rate) {\r\n//     var r = rate + 1;\r\n//     var result = 0;\r\n//     for (var i = 1; i < values.length; i++) {\r\n//       var frac = dateTime.DAYS(dates[i], dates[0]) / 365;\r\n//       result -= frac * values[i] / Math.pow(r, frac + 1);\r\n//     }\r\n//     return result;\r\n//   };\r\n//\r\n//   // Check that values contains at least one positive value and one negative value\r\n//   var positive = false;\r\n//   var negative = false;\r\n//   for (var i = 0; i < values.length; i++) {\r\n//     if (values[i] > 0) {\r\n//       positive = true;\r\n//     }\r\n//     if (values[i] < 0) {\r\n//       negative = true;\r\n//     }\r\n//   }\r\n//\r\n//   // Return error if values does not contain at least one positive value and one negative value\r\n//   if (!positive || !negative) {\r\n//     return error.num;\r\n//   }\r\n//\r\n//   // Initialize guess and resultRate\r\n//   guess = guess || 0.1;\r\n//   var resultRate = guess;\r\n//\r\n//   // Set maximum epsilon for end of iteration\r\n//   var epsMax = 1e-10;\r\n//\r\n//   // Implement Newton's method\r\n//   var newRate, epsRate, resultValue;\r\n//   var contLoop = true;\r\n//   do {\r\n//     resultValue = irrResult(values, dates, resultRate);\r\n//     newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);\r\n//     epsRate = Math.abs(newRate - resultRate);\r\n//     resultRate = newRate;\r\n//     contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);\r\n//   } while (contLoop);\r\n//\r\n//   // Return internal rate of return\r\n//   return resultRate;\r\n// };\r\n\r\nexports.XNPV = function(rate, values, dates) {\r\n  rate = utils.parseNumber(rate);\r\n  values = utils.parseNumberArray(utils.flatten(values));\r\n  dates = utils.parseDateArray(utils.flatten(dates));\r\n  if (utils.anyIsError(rate, values, dates)) {\r\n    return error.value;\r\n  }\r\n\r\n  var result = 0;\r\n  for (var i = 0; i < values.length; i++) {\r\n    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);\r\n  }\r\n  return result;\r\n};\r\n\r\n// TODO\r\nexports.YIELD = function() {\r\n  throw new Error('YIELD is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.YIELDDISC = function() {\r\n  throw new Error('YIELDDISC is not implemented');\r\n};\r\n\r\n// TODO\r\nexports.YIELDMAT = function() {\r\n  throw new Error('YIELDMAT is not implemented');\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/financial.js\n// module id = 29\n// module chunks = 0","var error = require('./error');\r\nvar utils = require('./utils');\r\n\r\nexports.INDEX = function(lookupArray, lookupRow, lookupColumn) {\r\n  if (!lookupArray && !lookupRow) {\r\n    return error.na;\r\n  }\r\n\r\n  if (!(lookupArray instanceof Array)) {\r\n    return error.na;\r\n  }\r\n\r\n  if (arguments.length === 2) {\r\n    if (lookupArray[0].length === 1) {\r\n      lookupArray = lookupArray.flatten();\r\n    }\r\n    return lookupArray[lookupRow - 1];\r\n  } else {\r\n    return lookupArray[lookupRow - 1][lookupColumn - 1];\r\n  }\r\n};\r\n\r\nexports.MATCH = function(lookupValue, lookupArray, matchType) {\r\n  if (matchType === true) {\r\n    matchType = 1;\r\n  }\r\n\r\n  if (!lookupValue && !lookupArray) {\r\n    return error.na;\r\n  }\r\n\r\n  if (arguments.length === 2) {\r\n    matchType = 1;\r\n  }\r\n  if (!(lookupArray instanceof Array)) {\r\n    return error.na;\r\n  }\r\n\r\n  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {\r\n    return error.na;\r\n  }\r\n\r\n  lookupArray = lookupArray.flatten();\r\n\r\n  var index;\r\n  var indexValue;\r\n  for (var idx = 0; idx < lookupArray.length; idx++) {\r\n    if (matchType === 1) {\r\n      if (lookupArray[idx] === lookupValue) {\r\n        return idx + 1;\r\n      } else if (lookupArray[idx] < lookupValue) {\r\n        if (!indexValue) {\r\n          index = idx + 1;\r\n          indexValue = lookupArray[idx];\r\n        } else if (lookupArray[idx] > indexValue) {\r\n          index = idx + 1;\r\n          indexValue = lookupArray[idx];\r\n        }\r\n      }\r\n    } else if (matchType === 0) {\r\n      if (typeof lookupValue === 'string') {\r\n        lookupValue = lookupValue.replace(/\\?/g, '.');\r\n        if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {\r\n          return idx + 1;\r\n        }\r\n      } else {\r\n        if (lookupArray[idx] === lookupValue) {\r\n          return idx + 1;\r\n        }\r\n      }\r\n    } else if (matchType === -1) {\r\n      if (lookupArray[idx] === lookupValue) {\r\n        return idx + 1;\r\n      } else if (lookupArray[idx] > lookupValue) {\r\n        if (!indexValue) {\r\n          index = idx + 1;\r\n          indexValue = lookupArray[idx];\r\n        } else if (lookupArray[idx] < indexValue) {\r\n          index = idx + 1;\r\n          indexValue = lookupArray[idx];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return index ? index : error.na;\r\n};\r\n\r\nexports.VLOOKUP = function (needle, table, index, rangeLookup = true) {\r\n  if ((!needle && needle !== 0) || !table || !index) {\r\n    return '';\r\n  }\r\n\r\n  for (var i = 0; i < table.length; i++) {\r\n    var row = table[i];\r\n    if (!rangeLookup) {\r\n      if (row[0] === needle) {\r\n        return (index < (row.length + 1) ? row[index - 1] : error.ref);\r\n      }\r\n    } else {\r\n      if (!isNaN(needle)) {\r\n        needle = utils.parseNumber(needle);\r\n        var startRange = utils.parseNumber(row[0]);\r\n        var isLastIndex = i === (table.length - 1) ? true : false;\r\n        if (isLastIndex) {\r\n          return (index < (row.length + 1) ? row[index - 1] : error.ref);\r\n        } else {\r\n          var endRange = utils.parseNumber(table[i + 1][0]) - 1;\r\n          if (needle >= startRange && needle <= endRange) {\r\n            return (index < (row.length + 1) ? row[index - 1] : error.ref);\r\n          }\r\n        }\r\n      } else {\r\n        if (row[0].toLowerCase().indexOf(needle.toLowerCase()) !== -1) {\r\n          return (index < (row.length + 1) ? row[index - 1] : error.ref);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return needle == true ? 0 : error.na;\r\n};\r\n\r\nexports.HLOOKUP = function (needle, table, index, rangeLookup) {\r\n  if ((!needle && needle !== 0) || !table || !index) {\r\n    return error.na;\r\n  }\r\n\r\n  rangeLookup = rangeLookup || false;\r\n\r\n  var transposedTable = utils.transpose(table);\r\n\r\n  for (var i = 0; i < transposedTable.length; i++) {\r\n    var row = transposedTable[i];\r\n    if ((!rangeLookup && row[0] === needle) ||\r\n      ((row[0] === needle) ||\r\n        (rangeLookup && typeof row[0] === \"string\" && row[0].toLowerCase().indexOf(needle.toLowerCase()) !== -1))) {\r\n      return (index < (row.length + 1) ? row[index - 1] : error.ref);\r\n    }\r\n  }\r\n\r\n  return error.na;\r\n};\r\n\r\nexports.LOOKUP = function() {\r\n  var lookupValue, lookupArray, lookupVector, resultsVector;\r\n  if (arguments.length === 2) { // array form\r\n\r\n    lookupValue = arguments[0].valueOf();\r\n    lookupArray = arguments[1];\r\n\r\n    for (var i = 0; i < lookupArray.length; i++) {\r\n      if (typeof lookupArray[i] !== 'undefined' && lookupValue === lookupArray[i].valueOf()) {\r\n        return lookupArray[i];\r\n      }\r\n    }\r\n  } else if (arguments.length === 3) { // vector form\r\n    lookupValue = arguments[0].valueOf();\r\n    lookupVector = arguments[1];\r\n    resultsVector = arguments[2];\r\n\r\n    for (var i = 0; i < lookupVector.length; i++) {\r\n      if (typeof lookupVector[i] !== 'undefined' && lookupValue === lookupVector[i].valueOf()) {\r\n        return resultsVector[i];\r\n      }\r\n    }\r\n    var sortedLookup = lookupVector.concat(lookupValue).sort(function(a,b) {\r\n      return a - b;\r\n    });\r\n    var sortedIndex = sortedLookup.indexOf(lookupValue);\r\n    if (resultsVector[sortedIndex-1]) {\r\n      return resultsVector[sortedIndex-1];\r\n    }\r\n  }\r\n\r\n  return error.na;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/formulajs/lib/lookup-reference.js\n// module id = 30\n// module chunks = 0","export const SYMBOL = '>';\r\n\r\nexport default function func(exp1, exp2) {\r\n  return exp1 > exp2;\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/greater-than.js","export const SYMBOL = '>=';\r\n\r\nexport default function func(exp1, exp2) {\r\n  return exp1 >= exp2;\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/greater-than-or-equal.js","export const SYMBOL = '<';\r\n\r\nexport default function func(exp1, exp2) {\r\n  return exp1 < exp2;\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/less-than.js","export const SYMBOL = '<=';\r\n\r\nexport default function func(exp1, exp2) {\r\n  return exp1 <= exp2;\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/less-than-or-equal.js","import {toNumber} from './../../helper/number';\r\nimport {ERROR_VALUE} from './../../error';\r\nimport {undefinedCell} from './../../helper/undefined-cell';\r\nimport Decimal from 'decimal.js';\r\n\r\nexport const SYMBOL = '-';\r\n\r\nexport default function func(first, ...rest) {\r\n  try {\r\n    first = undefinedCell(first);\r\n\r\n    for (var i = 0; i < rest.length; i++) {\r\n      rest[i] = undefinedCell(rest[i]);\r\n    }\r\n\r\n    const result = rest.reduce((acc, value) => {\r\n      return (new Decimal(acc)).minus(new Decimal(value)).toNumber();\r\n    }, first);\r\n\r\n    if (isNaN(result)) {\r\n      throw Error(ERROR_VALUE);\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    throw Error(ERROR_VALUE);\r\n  }\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/minus.js","import { toNumber } from './../../helper/number';\r\nimport { ERROR_VALUE, } from './../../error';\r\nimport {undefinedCell} from './../../helper/undefined-cell';\r\nimport Decimal from 'decimal.js';\r\n\r\nexport const SYMBOL = '*';\r\n\r\nexport default function func(first, ...rest) {\r\n  try {\r\n    first = undefinedCell(first);\r\n\r\n    for (var i = 0; i < rest.length; i++) {\r\n      rest[i] = undefinedCell(rest[i]);\r\n    }\r\n\r\n    const result = rest.reduce((acc, value) => {\r\n      return (new Decimal(acc)).mul(new Decimal(value)).toNumber();\r\n    }, first);\r\n\r\n    if (isNaN(result)) {\r\n      throw Error(ERROR_VALUE);\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    throw Error(ERROR_VALUE);\r\n  }\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/multiply.js","export const SYMBOL = '<>';\r\n\r\nexport default function func(exp1, exp2) {\r\n  return exp1 !== exp2;\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/not-equal.js","import { toNumber } from './../../helper/number';\r\nimport { ERROR_VALUE } from './../../error';\r\nimport Decimal from 'decimal.js';\r\n\r\nexport const SYMBOL = '^';\r\n\r\nexport default function func(exp1, exp2) {\r\n  if (!Number.isInteger(toNumber(exp2))) {\r\n    throw Error(ERROR_VALUE);\r\n  }\r\n\r\n  const result = (new Decimal(toNumber(exp1)).toPower(toNumber(exp2))).toNumber();\r\n  if (isNaN(result)) {\r\n    throw Error(ERROR_VALUE);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nfunc.SYMBOL = SYMBOL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/evaluate-by-operator/operator/power.js","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,5],$V1=[1,8],$V2=[1,6],$V3=[1,7],$V4=[1,9],$V5=[1,10],$V6=[1,11],$V7=[1,19],$V8=[1,20],$V9=[1,21],$Va=[1,22],$Vb=[1,17],$Vc=[1,18],$Vd=[1,23],$Ve=[1,25],$Vf=[1,26],$Vg=[1,27],$Vh=[1,28],$Vi=[1,29],$Vj=[1,30],$Vk=[1,31],$Vl=[1,32],$Vm=[1,33],$Vn=[1,34],$Vo=[5,9,10,11,13,14,15,16,17,18,19,20,35,36],$Vp=[5,9,10,11,13,14,15,16,17,18,19,20,35,36,38],$Vq=[5,9,10,11,13,14,15,16,17,18,19,20,35,36,40],$Vr=[5,10,11,13,14,15,16,17,35,36],$Vs=[5,10,13,14,15,16,35,36],$Vt=[5,10,11,13,14,15,16,17,18,19,35,36],$Vu=[13,35,36];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"expression\":4,\"EOF\":5,\"variableSequence\":6,\"number\":7,\"STRING\":8,\"&\":9,\"=\":10,\"+\":11,\"(\":12,\")\":13,\"<\":14,\">\":15,\"NOT\":16,\"-\":17,\"*\":18,\"/\":19,\"^\":20,\"FUNCTION\":21,\"expseq\":22,\"ARRAYCONSTANT\":23,\"ARRAY\":24,\"cell\":25,\"refCell\":26,\"range\":27,\"refRange\":28,\"ABSOLUTE_CELL\":29,\"RELATIVE_CELL\":30,\"MIXED_CELL\":31,\"REFSHEET\":32,\"!\":33,\":\":34,\";\":35,\",\":36,\"VARIABLE\":37,\"DECIMAL\":38,\"NUMBER\":39,\"%\":40,\"ERROR\":41,\"$accept\":0,\"$end\":1},\nterminals_: {5:\"EOF\",8:\"STRING\",9:\"&\",10:\"=\",11:\"+\",12:\"(\",13:\")\",14:\"<\",15:\">\",16:\"NOT\",17:\"-\",18:\"*\",19:\"/\",20:\"^\",21:\"FUNCTION\",23:\"ARRAYCONSTANT\",24:\"ARRAY\",29:\"ABSOLUTE_CELL\",30:\"RELATIVE_CELL\",31:\"MIXED_CELL\",32:\"REFSHEET\",33:\"!\",34:\":\",35:\";\",36:\",\",37:\"VARIABLE\",38:\"DECIMAL\",39:\"NUMBER\",40:\"%\",41:\"ERROR\"},\nproductions_: [0,[3,2],[4,1],[4,1],[4,1],[4,3],[4,3],[4,3],[4,3],[4,4],[4,4],[4,4],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,2],[4,3],[4,4],[4,1],[4,1],[4,1],[4,1],[4,1],[4,1],[4,1],[4,2],[25,1],[25,1],[25,1],[26,3],[26,3],[26,3],[27,3],[27,3],[27,3],[27,3],[27,3],[27,3],[27,3],[27,3],[27,3],[28,5],[28,5],[28,5],[28,5],[28,5],[28,5],[28,5],[28,5],[28,5],[22,1],[22,3],[22,3],[6,1],[6,3],[7,1],[7,3],[7,2],[2,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n\n      return $$[$0-1];\n    \nbreak;\ncase 2:\n\n      this.$ = yy.callVariable($$[$0][0]);\n    \nbreak;\ncase 3:\n\n      this.$ = yy.toNumber($$[$0]);\n    \nbreak;\ncase 4:\n\n      this.$ = yy.trimEdges($$[$0]);\n    \nbreak;\ncase 5:\n\n      this.$ = yy.evaluateByOperator('&', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 6:\n\n      this.$ = yy.evaluateByOperator('=', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 7:\n\n      this.$ = yy.evaluateByOperator('+', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 8:\n\n      this.$ = $$[$0-1];\n    \nbreak;\ncase 9:\n\n      this.$ = yy.evaluateByOperator('<=', [$$[$0-3], $$[$0]]);\n    \nbreak;\ncase 10:\n\n      this.$ = yy.evaluateByOperator('>=', [$$[$0-3], $$[$0]]);\n    \nbreak;\ncase 11:\n\n      this.$ = yy.evaluateByOperator('<>', [$$[$0-3], $$[$0]]);\n    \nbreak;\ncase 12:\n\n      this.$ = yy.evaluateByOperator('NOT', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 13:\n\n      this.$ = yy.evaluateByOperator('>', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 14:\n\n      this.$ = yy.evaluateByOperator('<', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 15:\n\n      this.$ = yy.evaluateByOperator('-', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 16:\n\n      this.$ = yy.evaluateByOperator('*', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 17:\n\n      this.$ = yy.evaluateByOperator('/', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 18:\n\n      this.$ = yy.evaluateByOperator('^', [$$[$0-2], $$[$0]]);\n    \nbreak;\ncase 19:\n\n      var n1 = yy.invertNumber($$[$0]);\n\n      this.$ = n1;\n\n      if (isNaN(this.$)) {\n          this.$ = 0;\n      }\n    \nbreak;\ncase 20:\n\n      var n1 = yy.toNumber($$[$0]);\n\n      this.$ = n1;\n\n      if (isNaN(this.$)) {\n          this.$ = 0;\n      }\n    \nbreak;\ncase 21:\n\n      this.$ = yy.callFunction($$[$0-2]);\n    \nbreak;\ncase 22:\n\n      this.$ = yy.callFunction($$[$0-3], $$[$0-1]);\n    \nbreak;\ncase 23:\n\n      var result = [];\n\n      var textInArray = yytext.replace('{','').replace('}','');\n\n      var arr = textInArray.split(';');\n      if(arr.length <= 1) {\n        var arr = eval(\"[[\" + arr + \"]]\");\n        arr.forEach(function(item) {\n          result.push(item);\n        });\n      } else {\n        for(var i = 0; i < arr.length; i++) {\n          result.push(eval(\"[\" + arr[i] + \"]\"));\n        }\n      }\n\n      this.$ = result;\n  \nbreak;\ncase 24:\n\n      var result = [];\n      var arr = eval(\"[\" + yytext + \"]\");\n\n      arr.forEach(function(item) {\n        result.push(item);\n      });\n      this.$ = result;\n  \nbreak;\ncase 31: case 32: case 33:\n\n      this.$ = yy.cellValue($$[$0]);\n    \nbreak;\ncase 34:\n\n\n      this.$ = yy.cellValue($$[$0], $$[$0-2].replace(/'/g, \"\"));\n    \nbreak;\ncase 35:\n\n      this.$ = yy.cellValue($$[$0], $$[$0-2].replace(/'/g, \"\"));\n    \nbreak;\ncase 36:\n\n    this.$ = yy.cellValue($$[$0], $$[$0-2].replace(/'/g, \"\"));\n  \nbreak;\ncase 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45:\n\n      this.$ = yy.rangeValue($$[$0-2], $$[$0]);\n    \nbreak;\ncase 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54:\n\n      this.$ = yy.rangeValue($$[$0-2], $$[$0], $$[$0-4].replace(/'/g, \"\"));\n    \nbreak;\ncase 55: case 58:\n\n      this.$ = [$$[$0]];\n    \nbreak;\ncase 56: case 57:\n\n      $$[$0-2].push($$[$0]);\n      this.$ = $$[$0-2];\n    \nbreak;\ncase 59:\n\n      this.$ = (Array.isArray($$[$0-2]) ? $$[$0-2] : [$$[$0-2]]);\n      this.$.push($$[$0]);\n    \nbreak;\ncase 60:\n\n      this.$ = $$[$0];\n    \nbreak;\ncase 61:\n\n      this.$ = ($$[$0-2] + '.' + $$[$0]) * 1;\n    \nbreak;\ncase 62:\n\n      this.$ = $$[$0-1] * 0.01;\n    \nbreak;\ncase 63:\n\n      this.$ = yy.throwError($$[$0]);\n    \nbreak;\n}\n},\ntable: [{2:16,3:1,4:2,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{1:[3]},{5:[1,24],9:$Ve,10:$Vf,11:$Vg,14:$Vh,15:$Vi,16:$Vj,17:$Vk,18:$Vl,19:$Vm,20:$Vn},o($Vo,[2,2],{38:[1,35]}),o($Vo,[2,3],{40:[1,36]}),o($Vo,[2,4]),{2:16,4:37,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:38,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:39,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{12:[1,40]},o($Vo,[2,23]),o($Vo,[2,24]),o($Vo,[2,25]),o($Vo,[2,26]),o($Vo,[2,27]),o($Vo,[2,28]),o($Vo,[2,29],{2:41,41:$Vd}),o($Vp,[2,58]),o($Vq,[2,60],{38:[1,42]}),o($Vo,[2,31],{34:[1,43]}),o($Vo,[2,32],{34:[1,44]}),o($Vo,[2,33],{34:[1,45]}),{33:[1,46]},o([5,9,10,11,13,14,15,16,17,18,19,20,35,36,41],[2,63]),{1:[2,1]},{2:16,4:47,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:48,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:49,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:52,6:3,7:4,8:$V0,10:[1,50],11:$V1,12:$V2,15:[1,51],17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:54,6:3,7:4,8:$V0,10:[1,53],11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:55,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:56,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:57,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:58,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:59,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{37:[1,60]},o($Vq,[2,62]),{9:$Ve,10:$Vf,11:$Vg,13:[1,61],14:$Vh,15:$Vi,16:$Vj,17:$Vk,18:$Vl,19:$Vm,20:$Vn},o($Vr,[2,19],{9:$Ve,18:$Vl,19:$Vm,20:$Vn}),o($Vr,[2,20],{9:$Ve,18:$Vl,19:$Vm,20:$Vn}),{2:16,4:64,6:3,7:4,8:$V0,11:$V1,12:$V2,13:[1,62],17:$V3,21:$V4,22:63,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},o($Vo,[2,30]),{39:[1,65]},{29:[1,66],30:[1,67],31:[1,68]},{29:[1,69],30:[1,70],31:[1,71]},{29:[1,72],30:[1,73],31:[1,74]},{29:[1,75],30:[1,76],31:[1,77]},o($Vo,[2,5]),o([5,10,13,35,36],[2,6],{9:$Ve,11:$Vg,14:$Vh,15:$Vi,16:$Vj,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vr,[2,7],{9:$Ve,18:$Vl,19:$Vm,20:$Vn}),{2:16,4:78,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:79,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},o($Vs,[2,14],{9:$Ve,11:$Vg,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),{2:16,4:80,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},o($Vs,[2,13],{9:$Ve,11:$Vg,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o([5,10,13,16,35,36],[2,12],{9:$Ve,11:$Vg,14:$Vh,15:$Vi,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vr,[2,15],{9:$Ve,18:$Vl,19:$Vm,20:$Vn}),o($Vt,[2,16],{9:$Ve,20:$Vn}),o($Vt,[2,17],{9:$Ve,20:$Vn}),o([5,10,11,13,14,15,16,17,18,19,20,35,36],[2,18],{9:$Ve}),o($Vp,[2,59]),o($Vo,[2,8]),o($Vo,[2,21]),{13:[1,81],35:[1,82],36:[1,83]},o($Vu,[2,55],{9:$Ve,10:$Vf,11:$Vg,14:$Vh,15:$Vi,16:$Vj,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vq,[2,61]),o($Vo,[2,37]),o($Vo,[2,38]),o($Vo,[2,39]),o($Vo,[2,40]),o($Vo,[2,41]),o($Vo,[2,42]),o($Vo,[2,43]),o($Vo,[2,44]),o($Vo,[2,45]),o($Vo,[2,34],{34:[1,84]}),o($Vo,[2,35],{34:[1,85]}),o($Vo,[2,36],{34:[1,86]}),o($Vs,[2,9],{9:$Ve,11:$Vg,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vs,[2,11],{9:$Ve,11:$Vg,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vs,[2,10],{9:$Ve,11:$Vg,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vo,[2,22]),{2:16,4:87,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{2:16,4:88,6:3,7:4,8:$V0,11:$V1,12:$V2,17:$V3,21:$V4,23:$V5,24:$V6,25:12,26:13,27:14,28:15,29:$V7,30:$V8,31:$V9,32:$Va,37:$Vb,39:$Vc,41:$Vd},{29:[1,89],30:[1,90],31:[1,91]},{29:[1,92],30:[1,93],31:[1,94]},{29:[1,95],30:[1,96],31:[1,97]},o($Vu,[2,56],{9:$Ve,10:$Vf,11:$Vg,14:$Vh,15:$Vi,16:$Vj,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vu,[2,57],{9:$Ve,10:$Vf,11:$Vg,14:$Vh,15:$Vi,16:$Vj,17:$Vk,18:$Vl,19:$Vm,20:$Vn}),o($Vo,[2,46]),o($Vo,[2,47]),o($Vo,[2,48]),o($Vo,[2,49]),o($Vo,[2,50]),o($Vo,[2,51]),o($Vo,[2,52]),o($Vo,[2,53]),o($Vo,[2,54])],\ndefaultActions: {24:[2,1]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse (input) {\n    var self = this,\n        stack = [0],\n        tstack = [], // token stack\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    var args = lstack.slice.call(arguments, 1);\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    // copy state\n    for (var k in this.yy) {\n      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n        sharedState.yy[k] = this.yy[k];\n      }\n    }\n\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n\n    var ranges = lexer.options && lexer.options.ranges;\n\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n\n    function popStack (n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n_token_stack:\n    var lex = function () {\n        var token;\n        token = lexer.lex() || EOF;\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length - 1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n_handle_error:\n        // handle parse error\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n            var error_rule_depth;\n            var errStr = '';\n\n            // Return the rule stack depth where the nearest error rule can be found.\n            // Return FALSE when no error recovery rule was found.\n            function locateNearestErrorRecoveryRule(state) {\n                var stack_probe = stack.length - 1;\n                var depth = 0;\n\n                // try to recover from error\n                for(;;) {\n                    // check for error recovery rule in this state\n                    if ((TERROR.toString()) in table[state]) {\n                        return depth;\n                    }\n                    if (state === 0 || stack_probe < 2) {\n                        return false; // No suitable error recovery rule available.\n                    }\n                    stack_probe -= 2; // popStack(1): [symbol, action]\n                    state = stack[stack_probe];\n                    ++depth;\n                }\n            }\n\n            if (!recovering) {\n                // first see if there's any chance at hitting an error recovery rule:\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n\n                // Report error\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push(\"'\"+this.terminals_[p]+\"'\");\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol)+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == EOF ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected,\n                    recoverable: (error_rule_depth !== false)\n                });\n            } else if (preErrorSymbol !== EOF) {\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol === EOF || preErrorSymbol === EOF) {\n                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            if (error_rule_depth === false) {\n                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\n            }\n            popStack(error_rule_depth);\n\n            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(lexer.yytext);\n                lstack.push(lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = lexer.yyleng;\n                    yytext = lexer.yytext;\n                    yylineno = lexer.yylineno;\n                    yyloc = lexer.yylloc;\n                    if (recovering > 0) {\n                        recovering--;\n                    }\n                } else {\n                    // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2:\n                // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                if (ranges) {\n                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];\n                }\n                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3:\n                // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:\nbreak;\ncase 1:return 8;\nbreak;\ncase 2:return 32;\nbreak;\ncase 3:return 8;\nbreak;\ncase 4:return 21;\nbreak;\ncase 5:return 41;\nbreak;\ncase 6:return 29;\nbreak;\ncase 7:return 31;\nbreak;\ncase 8:return 31;\nbreak;\ncase 9:return 30;\nbreak;\ncase 10:return 32;\nbreak;\ncase 11:return 21;\nbreak;\ncase 12:return 37;\nbreak;\ncase 13:return 37;\nbreak;\ncase 14:return 39;\nbreak;\ncase 15:return 24;\nbreak;\ncase 16:return 23;\nbreak;\ncase 17:return 9;\nbreak;\ncase 18:return ' ';\nbreak;\ncase 19:return 38;\nbreak;\ncase 20:return 34;\nbreak;\ncase 21:return 35;\nbreak;\ncase 22:return 36;\nbreak;\ncase 23:return 18;\nbreak;\ncase 24:return 19;\nbreak;\ncase 25:return 17;\nbreak;\ncase 26:return 11;\nbreak;\ncase 27:return 20;\nbreak;\ncase 28:return 12;\nbreak;\ncase 29:return 13;\nbreak;\ncase 30:return 15;\nbreak;\ncase 31:return 14;\nbreak;\ncase 32:return 16;\nbreak;\ncase 33:return '\"';\nbreak;\ncase 34:return \"'\";\nbreak;\ncase 35:return \"!\";\nbreak;\ncase 36:return 10;\nbreak;\ncase 37:return 40;\nbreak;\ncase 38:return '{';\nbreak;\ncase 39:return '}';\nbreak;\ncase 40:return '#';\nbreak;\ncase 41:return 5;\nbreak;\n}\n},\nrules: [/^(?:\\s+)/,/^(?:\"(\\\\[\"]|[^\"])*\")/,/^(?:'((?![\\\\\\/\\[\\]\\*\\?\\:]).)+?'(?=))/,/^(?:'(\\\\[']|[^'])*')/,/^(?:[A-Za-z]{1,}[A-Za-z_0-9\\.]+(?=[(]))/,/^(?:#[A-Z0-9\\/]+(!|\\?)?)/,/^(?:\\$[A-Za-z]+\\$[0-9]+)/,/^(?:\\$[A-Za-z]+[0-9]+)/,/^(?:[A-Za-z]+\\$[0-9]+)/,/^(?:[A-Za-z]+[0-9]+(?![!]))/,/^(?:[A-Za-z_\\.\\d]+(?=[!]))/,/^(?:[A-Za-z\\.]+(?=[(]))/,/^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/,/^(?:[A-Za-z_]+)/,/^(?:[0-9]+)/,/^(?:\\[([\\w\\,\\;\\s]*)?\\])/,/^(?:\\{([\\w\\,\\;\\\"\\.\\s]*)?\\})/,/^(?:&)/,/^(?: )/,/^(?:[.])/,/^(?::)/,/^(?:;)/,/^(?:,)/,/^(?:\\*)/,/^(?:\\/)/,/^(?:-)/,/^(?:\\+)/,/^(?:\\^)/,/^(?:\\()/,/^(?:\\))/,/^(?:>)/,/^(?:<)/,/^(?:NOT\\b)/,/^(?:\")/,/^(?:')/,/^(?:!)/,/^(?:=)/,/^(?:%)/,/^(?:\\{)/,/^(?:\\})/,/^(?:[#])/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n\n\n// WEBPACK FOOTER //\n// ./src/grammar-parser/grammar-parser.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 40\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 41\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 42\n// module chunks = 0","/**\r\n * Trim value by cutting character starting from the beginning and ending at the same time.\r\n *\r\n * @param {String} string String to trimming.\r\n * @param {Number} [margin=1] Number of character to cut.\r\n * @returns {String}\r\n */\r\nexport function trimEdges(string, margin = 1) {\r\n  string = string.substring(margin, string.length - margin);\r\n\r\n  return string;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper/string.js","const LABEL_EXTRACT_REGEXP = /^([$])?([A-Za-z]+)([$])?([0-9]+)$/;\r\n\r\n/**\r\n * Extract cell coordinates.\r\n *\r\n * @param {String} label Cell coordinates (eq. 'A1', '$B6', '$N$98').\r\n * @returns {Array} Returns an array of objects.\r\n */\r\nexport function extractLabel(label) {\r\n  if (typeof label !== 'string' || !LABEL_EXTRACT_REGEXP.test(label)) {\r\n    return [];\r\n  }\r\n  const [, columnAbs, column, rowAbs, row] = label.toUpperCase().match(LABEL_EXTRACT_REGEXP);\r\n\r\n  return [\r\n    {\r\n      index: rowLabelToIndex(row),\r\n      label: row,\r\n      isAbsolute: rowAbs === '$',\r\n    },\r\n    {\r\n      index: columnLabelToIndex(column),\r\n      label: column,\r\n      isAbsolute: columnAbs === '$'\r\n    }\r\n  ];\r\n}\r\n\r\n/**\r\n * Convert row and column indexes into cell label.\r\n *\r\n * @param {Object} row Object with `index` and `isAbsolute` properties.\r\n * @param {Object} column Object with `index` and `isAbsolute` properties.\r\n * @returns {String} Returns cell label.\r\n */\r\nexport function toLabel(row, column) {\r\n  const rowLabel = (row.isAbsolute ? '$' : '') + rowIndexToLabel(row.index);\r\n  const columnLabel = (column.isAbsolute ? '$' : '') + columnIndexToLabel(column.index);\r\n\r\n  return columnLabel + rowLabel;\r\n}\r\n\r\nconst COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\nconst COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;\r\n\r\n/**\r\n * Convert column label to index.\r\n *\r\n * @param {String} label Column label (eq. 'ABB', 'CNQ')\r\n * @returns {Number} Returns -1 if label is not recognized otherwise proper column index.\r\n */\r\nexport function columnLabelToIndex(label) {\r\n  let result = 0;\r\n\r\n  if (typeof label === 'string') {\r\n    label = label.toUpperCase();\r\n\r\n    for (let i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {\r\n      result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);\r\n    }\r\n  }\r\n  --result;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Convert column index to label.\r\n *\r\n * @param {Number} column Column index.\r\n * @returns {String} Returns column label (eq. 'ABB', 'CNQ').\r\n */\r\nexport function columnIndexToLabel(column) {\r\n  let result = '';\r\n\r\n  while (column >= 0) {\r\n    result = String.fromCharCode(column % COLUMN_LABEL_BASE_LENGTH + 97) + result;\r\n    column = Math.floor(column / COLUMN_LABEL_BASE_LENGTH) - 1;\r\n  }\r\n\r\n  return result.toUpperCase();\r\n}\r\n\r\n/**\r\n * Convert row label to index.\r\n *\r\n * @param {String} label Row label (eq. '1', '5')\r\n * @returns {Number} Returns -1 if label is not recognized otherwise proper row index.\r\n */\r\nexport function rowLabelToIndex(label) {\r\n  let result = parseInt(label, 10);\r\n\r\n  if (isNaN(result)) {\r\n    result = -1;\r\n  } else {\r\n    result = Math.max(result - 1, -1);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Convert row index to label.\r\n *\r\n * @param {Number} row Row index.\r\n * @returns {String} Returns row label (eq. '1', '7').\r\n */\r\nexport function rowIndexToLabel(row) {\r\n  let result = '';\r\n\r\n  if (row >= 0) {\r\n    result = `${row + 1}`;\r\n  }\r\n\r\n  return result;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper/cell.js"],"sourceRoot":""}